import{Vector3 as e,Matrix4 as t,MathUtils as n,Loader as i,FileLoader as r,Data3DTexture as o,DataTexture as a,RGBAFormat as s,ClampToEdgeWrapping as c,LinearFilter as u,UnsignedByteType as l,ByteType as d,FloatType as h,Uniform as m,Vector2 as f,Camera as v,LightProbe as p,GLSL3 as _,Color as g,BufferGeometry as T,InterleavedBuffer as R,InterleavedBufferAttribute as S,Sphere as E,DirectionalLight as w,RawShaderMaterial as y,WebGLRenderTarget as A,HalfFloatType as x,ShaderMaterial as C,NoBlending as I,Mesh as M,PlaneGeometry as N,WebGLCubeRenderTarget as D,CubeCamera as O,Points as b}from"three";import{BlendFunction as P,Effect as U,EffectAttribute as L,Resolution as H,ShaderPass as G,MipmapBlurPass as F,KawaseBlurPass as z,KernelSize as B}from"postprocessing";var k=Object.defineProperty,W=(e,t,n)=>((e,t,n)=>t in e?k(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);const V=new e;function j(t,n,i=new e,r){const{x:o,y:a,z:s}=t,c=n.x,u=n.y,l=n.z,d=o*o*c,h=a*a*u,m=s*s*l,f=d+h+m,v=Math.sqrt(1/f);if(!Number.isFinite(v))return;const p=V.copy(t).multiplyScalar(v);if(f<((null==r?void 0:r.centerTolerance)??.1))return i.copy(p);const _=p.multiply(n).multiplyScalar(2);let g,T,R,S,E=(1-v)*t.length()/(_.length()/2),w=0;do{E-=w,g=1/(1+E*c),T=1/(1+E*u),R=1/(1+E*l);const e=g*g,t=T*T,n=R*R;S=d*e+h*t+m*n-1,w=S/(-2*(d*(e*g)*c+h*(t*T)*u+m*(n*R)*l))}while(Math.abs(S)>1e-12);return i.set(o*g,a*T,s*R)}const q=new e,Y=new e,X=new e,K=class{constructor(t,n,i){W(this,"radii"),this.radii=new e(t,n,i)}get minimumRadius(){return Math.min(this.radii.x,this.radii.y,this.radii.z)}get maximumRadius(){return Math.max(this.radii.x,this.radii.y,this.radii.z)}reciprocalRadii(t=new e){const{x:n,y:i,z:r}=this.radii;return t.set(1/n,1/i,1/r)}reciprocalRadiiSquared(t=new e){const{x:n,y:i,z:r}=this.radii;return t.set(1/n**2,1/i**2,1/r**2)}projectOnSurface(t,n=new e,i){return j(t,this.reciprocalRadiiSquared(),n,i)}getSurfaceNormal(t,n=new e){return n.multiplyVectors(this.reciprocalRadiiSquared(q),t).normalize()}getEastNorthUpVectors(t,n=new e,i=new e,r=new e){this.getSurfaceNormal(t,r),n.set(-t.y,t.x,0).normalize(),i.crossVectors(r,n).normalize()}getEastNorthUpFrame(e,n=new t){const i=q,r=Y,o=X;return this.getEastNorthUpVectors(e,i,r,o),n.makeBasis(i,r,o).setPosition(e)}getIntersection(t,n=new e){const i=this.reciprocalRadii(q),r=Y.copy(i).multiply(t.origin),o=X.copy(i).multiply(t.direction),a=r.lengthSq(),s=o.lengthSq(),c=r.dot(o),u=c**2-s*(a-1);if(1===a)return n.copy(t.origin);if(a>1){if(c>=0||u<0)return;const e=Math.sqrt(u),i=(-c-e)/s,r=(-c+e)/s;return t.at(Math.min(i,r),n)}if(a<1){const e=c**2-s*(a-1),i=(-c+Math.sqrt(e))/s;return t.at(i,n)}return c<0?t.at(-c/s,n):void 0}getOsculatingSphereCenter(t,n,i=new e){const r=this.radii.x**2,o=q.set(t.x/r,t.y/r,t.z/this.radii.z**2).normalize();return i.copy(o.multiplyScalar(-n).add(t))}};W(K,"WGS84",new K(6378137,6378137,6356752.314245179));let $=K;const Z=new e,J=new e,Q=class t{constructor(e=0,t=0,n=0){this.longitude=e,this.latitude=t,this.height=n}set(e,t,n){return this.longitude=e,this.latitude=t,null!=n&&(this.height=n),this}clone(){return new t(this.longitude,this.latitude,this.height)}copy(e){return this.longitude=e.longitude,this.latitude=e.latitude,this.height=e.height,this}equals(e){return e.longitude===this.longitude&&e.latitude===this.latitude&&e.height===this.height}setLongitude(e){return this.longitude=e,this}setLatitude(e){return this.latitude=e,this}setHeight(e){return this.height=e,this}normalize(){return this.longitude<t.MIN_LONGITUDE&&(this.longitude+=2*Math.PI),this}setFromECEF(e,t){const n=((null==t?void 0:t.ellipsoid)??$.WGS84).reciprocalRadiiSquared(Z),i=j(e,n,J,t);if(null==i)throw new Error(`Could not project position to ellipsoid surface: ${e.toArray()}`);const r=Z.multiplyVectors(i,n).normalize();this.longitude=Math.atan2(r.y,r.x),this.latitude=Math.asin(r.z);const o=Z.subVectors(e,i);return this.height=Math.sign(o.dot(e))*o.length(),this}toECEF(t=new e,n){const i=(null==n?void 0:n.ellipsoid)??$.WGS84,r=Z.multiplyVectors(i.radii,i.radii),o=Math.cos(this.latitude),a=J.set(o*Math.cos(this.longitude),o*Math.sin(this.longitude),Math.sin(this.latitude)).normalize();return t.multiplyVectors(r,a),t.divideScalar(Math.sqrt(a.dot(t))).add(a.multiplyScalar(this.height))}fromArray(e,t=0){return this.longitude=e[t],this.latitude=e[t+1],this.height=e[t+2],this}toArray(e=[],t=0){return e[t]=this.longitude,e[t+1]=this.latitude,e[t+2]=this.height,e}*[Symbol.iterator](){yield this.longitude,yield this.latitude,yield this.height}};W(Q,"MIN_LONGITUDE",-Math.PI),W(Q,"MAX_LONGITUDE",Math.PI),W(Q,"MIN_LATITUDE",-Math.PI/2),W(Q,"MAX_LATITUDE",Math.PI/2);let ee=Q;var te=Object.defineProperty,ne=(e,t,n)=>((e,t,n)=>t in e?te(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n),ie="Invariant failed";function re(e,t){if(!e)throw new Error(ie)}class oe extends i{load(e,t,n,i){const o=new r(this.manager);o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(this.withCredentials),o.load(e,(n=>{re(n instanceof ArrayBuffer);try{t(n)}catch(t){null!=i?i(t):console.error(t),this.manager.itemError(e)}}),n,i)}}const ae=(e,t)=>function(e,t,n,i=!0){const r=new DataView(e),o=new t(r.byteLength/t.BYTES_PER_ELEMENT);for(let e=0,a=0;e<o.length;++e,a+=t.BYTES_PER_ELEMENT)o[e]=r[n](a,i);return o}(e,Float32Array,"getFloat32",t);class se extends i{load(e,t,n,i){const r=new oe(this.manager);r.setRequestHeader(this.requestHeader),r.setPath(this.path),r.setWithCredentials(this.withCredentials),r.load(e,(n=>{try{t(this.parseTypedArray(n))}catch(t){null!=i?i(t):console.error(t),this.manager.itemError(e)}}),n,i)}}const ce={format:s,wrapS:c,wrapT:c,minFilter:u,magFilter:u};class ue extends i{constructor(){super(...arguments),ne(this,"parameters",{})}load(e,t,n,i){const r=new this.Texture,o=new this.TypedArrayLoader(this.manager);o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(this.withCredentials),o.load(e,(e=>{r.image.data=e;const{width:n,height:i,depth:o,...a}=this.parameters;null!=n&&(r.image.width=n),null!=i&&(r.image.height=i),"depth"in r.image&&null!=o&&(r.image.depth=o);const s=function(e){const t=e instanceof Int8Array?"int8":e instanceof Uint8Array||e instanceof Uint8ClampedArray?"uint8":e instanceof Int16Array?"int16":e instanceof Uint16Array?"uint16":e instanceof Int32Array?"int32":e instanceof Uint32Array?"uint32":e instanceof Float32Array?"float32":e instanceof Float64Array?"float64":null;return re(null!=t),t}(e);r.type="uint8"===s?l:"int8"===s?d:h,Object.assign(r,a),r.needsUpdate=!0,t(r)}),n,i)}}function le(e,t,n){return class extends ue{constructor(){super(...arguments),ne(this,"Texture",e),ne(this,"TypedArrayLoader",function(e){return class extends se{constructor(){super(...arguments),ne(this,"parseTypedArray",e)}}}(t)),ne(this,"parameters",{...ce,...n})}}}function de(e,t){return le(o,e,t)}function he(e,t){return le(a,e,t)}const me=n.clamp;n.euclideanModulo,n.inverseLerp,n.lerp;const fe=n.degToRad;n.radToDeg,n.isPowerOfTwo,n.ceilPowerOfTwo,n.floorPowerOfTwo,n.normalize;const ve=n.mapLinear;const pe=class e{constructor(e=0,t=0,n=0,i=0){this.west=e,this.south=t,this.east=n,this.north=i}get width(){let e=this.east;return e<this.west&&(e+=2*Math.PI),e-this.west}get height(){return this.north-this.south}set(e,t,n,i){return this.west=e,this.south=t,this.east=n,this.north=i,this}clone(){return new e(this.west,this.south,this.east,this.north)}copy(e){return this.west=e.west,this.south=e.south,this.east=e.east,this.north=e.north,this}equals(e){return e.west===this.west&&e.south===this.south&&e.east===this.east&&e.north===this.north}at(e,t,n=new ee){return n.set(this.west+(this.east-this.west)*e,this.north+(this.south-this.north)*t)}fromArray(e,t=0){return this.west=e[t],this.south=e[t+1],this.east=e[t+2],this.north=e[t+3],this}toArray(e=[],t=0){return e[t]=this.west,e[t+1]=this.south,e[t+2]=this.east,e[t+3]=this.north,e}*[Symbol.iterator](){yield this.west,yield this.south,yield this.east,yield this.north}};ne(pe,"MAX",new pe(ee.MIN_LONGITUDE,ee.MIN_LATITUDE,ee.MAX_LONGITUDE,ee.MAX_LATITUDE));const _e=/^[ \t]*#include +"([\w\d./]+)"/gm;function ge(e,t){return e.replace(_e,((e,n)=>{const i=n.split("/").reduce(((e,t)=>"string"!=typeof e&&null!=e?e[t]:void 0),t);if("string"!=typeof i)throw new Error(`Could not find include for ${n}.`);return ge(i,t)}))}const Te=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*(?:i\s*\+\+|\+\+\s*i)\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Re(e,t,n,i){let r="";for(let e=parseInt(t);e<parseInt(n);++e)r+=i.replace(/\[\s*i\s*\]/g,"["+e+"]").replace(/UNROLLED_LOOP_INDEX/g,`${e}`);return r}const Se="float raySphereFirstIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const float radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  float c = dot(a, a) - radius * radius;\n  float discriminant = b * b - 4.0 * c;\n  return discriminant < 0.0\n    ? -1.0\n    : (-b - sqrt(discriminant)) * 0.5;\n}\n\nfloat raySphereFirstIntersection(const vec3 origin, const vec3 direction, const float radius) {\n  return raySphereFirstIntersection(origin, direction, vec3(0.0), radius);\n}\n\nvec4 raySphereFirstIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const vec4 radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  vec4 c = dot(a, a) - radius * radius;\n  vec4 discriminant = b * b - 4.0 * c;\n  vec4 mask = step(discriminant, vec4(0.0));\n  return mix((-b - sqrt(max(vec4(0.0), discriminant))) * 0.5, vec4(-1.0), mask);\n}\n\nvec4 raySphereFirstIntersection(const vec3 origin, const vec3 direction, const vec4 radius) {\n  return raySphereFirstIntersection(origin, direction, vec3(0.0), radius);\n}\n\nfloat raySphereSecondIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const float radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  float c = dot(a, a) - radius * radius;\n  float discriminant = b * b - 4.0 * c;\n  return discriminant < 0.0\n    ? -1.0\n    : (-b + sqrt(discriminant)) * 0.5;\n}\n\nfloat raySphereSecondIntersection(const vec3 origin, const vec3 direction, const float radius) {\n  return raySphereSecondIntersection(origin, direction, vec3(0.0), radius);\n}\n\nvec4 raySphereSecondIntersection(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const vec4 radius\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  vec4 c = dot(a, a) - radius * radius;\n  vec4 discriminant = b * b - 4.0 * c;\n  vec4 mask = step(discriminant, vec4(0.0));\n  return mix((-b + sqrt(max(vec4(0.0), discriminant))) * 0.5, vec4(-1.0), mask);\n}\n\nvec4 raySphereSecondIntersection(const vec3 origin, const vec3 direction, const vec4 radius) {\n  return raySphereSecondIntersection(origin, direction, vec3(0.0), radius);\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const float radius,\n  out float intersection1,\n  out float intersection2\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  float c = dot(a, a) - radius * radius;\n  float discriminant = b * b - 4.0 * c;\n  if (discriminant < 0.0) {\n    intersection1 = -1.0;\n    intersection2 = -1.0;\n    return;\n  } else {\n    float Q = sqrt(discriminant);\n    intersection1 = (-b - Q) * 0.5;\n    intersection2 = (-b + Q) * 0.5;\n  }\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const float radius,\n  out float intersection1,\n  out float intersection2\n) {\n  raySphereIntersections(origin, direction, vec3(0.0), radius, intersection1, intersection2);\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const vec3 center,\n  const vec4 radius,\n  out vec4 intersection1,\n  out vec4 intersection2\n) {\n  vec3 a = origin - center;\n  float b = 2.0 * dot(direction, a);\n  vec4 c = dot(a, a) - radius * radius;\n  vec4 discriminant = b * b - 4.0 * c;\n  vec4 mask = step(discriminant, vec4(0.0));\n  vec4 Q = sqrt(max(vec4(0.0), discriminant));\n  intersection1 = mix((-b - Q) * 0.5, vec4(-1.0), mask);\n  intersection2 = mix((-b + Q) * 0.5, vec4(-1.0), mask);\n}\n\nvoid raySphereIntersections(\n  const vec3 origin,\n  const vec3 direction,\n  const vec4 radius,\n  out vec4 intersection1,\n  out vec4 intersection2\n) {\n  raySphereIntersections(origin, direction, vec3(0.0), radius, intersection1, intersection2);\n}\n",Ee='// Based on the following work and adapted to Three.js.\n// This file includes runtime functions only. Please refer to Bruneton\'s source\n// code for the whole picture. It has detailed comments.\n// https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl\n\n/**\n * Copyright (c) 2017 Eric Bruneton\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Precomputed Atmospheric Scattering\n * Copyright (c) 2008 INRIA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nfloat ClampCosine(float mu) {\n  return clamp(mu, float(-1.0), float(1.0));\n}\n\nfloat ClampDistance(float d) {\n  return max(d, 0.0);\n}\n\nfloat ClampRadius(float r) {\n  return clamp(r, u_bottom_radius, u_top_radius);\n}\n\nfloat SafeSqrt(float a) {\n  return sqrt(max(a, 0.0));\n}\n\nfloat DistanceToTopAtmosphereBoundary(float r, float mu) {\n  float discriminant = r * r * (mu * mu - 1.0) + u_top_radius * u_top_radius;\n  return ClampDistance(-r * mu + SafeSqrt(discriminant));\n}\n\nbool RayIntersectsGround(float r, float mu) {\n  return mu < 0.0 && r * r * (mu * mu - 1.0) + u_bottom_radius * u_bottom_radius >= 0.0;\n}\n\nfloat GetTextureCoordFromUnitRange(float x, int texture_size) {\n  return 0.5 / float(texture_size) + x * (1.0 - 1.0 / float(texture_size));\n}\n\nvec2 GetTransmittanceTextureUvFromRMu(float r, float mu) {\n  float H = sqrt(u_top_radius * u_top_radius - u_bottom_radius * u_bottom_radius);\n  float rho = SafeSqrt(r * r - u_bottom_radius * u_bottom_radius);\n  float d = DistanceToTopAtmosphereBoundary(r, mu);\n  float d_min = u_top_radius - r;\n  float d_max = rho + H;\n  float x_mu = (d - d_min) / (d_max - d_min);\n  float x_r = rho / H;\n  return vec2(\n    GetTextureCoordFromUnitRange(x_mu, TRANSMITTANCE_TEXTURE_WIDTH),\n    GetTextureCoordFromUnitRange(x_r, TRANSMITTANCE_TEXTURE_HEIGHT)\n  );\n}\n\nvec3 GetTransmittanceToTopAtmosphereBoundary(\n  const sampler2D u_transmittance_texture,\n  float r,\n  float mu\n) {\n  vec2 uv = GetTransmittanceTextureUvFromRMu(r, mu);\n  return vec3(texture(u_transmittance_texture, uv));\n}\n\nvec3 GetTransmittance(\n  const sampler2D u_transmittance_texture,\n  float r,\n  float mu,\n  float d,\n  bool ray_r_mu_intersects_ground\n) {\n  float r_d = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));\n  float mu_d = ClampCosine((r * mu + d) / r_d);\n  if (ray_r_mu_intersects_ground) {\n    return min(\n      GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r_d, -mu_d) /\n        GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r, -mu),\n      vec3(1.0)\n    );\n  } else {\n    return min(\n      GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r, mu) /\n        GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r_d, mu_d),\n      vec3(1.0)\n    );\n  }\n}\n\nvec3 GetTransmittanceToSun(const sampler2D u_transmittance_texture, float r, float mu_s) {\n  float sin_theta_h = u_bottom_radius / r;\n  float cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));\n  return GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r, mu_s) *\n  smoothstep(\n    -sin_theta_h * u_sun_angular_radius,\n    sin_theta_h * u_sun_angular_radius,\n    mu_s - cos_theta_h\n  );\n}\n\nfloat RayleighPhaseFunction(float nu) {\n  float k = 3.0 / (16.0 * PI);\n  return k * (1.0 + nu * nu);\n}\n\nfloat MiePhaseFunction(float g, float nu) {\n  float k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);\n  return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);\n}\n\nvec4 GetScatteringTextureUvwzFromRMuMuSNu(\n  float r,\n  float mu,\n  float mu_s,\n  float nu,\n  bool ray_r_mu_intersects_ground\n) {\n  float H = sqrt(u_top_radius * u_top_radius - u_bottom_radius * u_bottom_radius);\n  float rho = SafeSqrt(r * r - u_bottom_radius * u_bottom_radius);\n  float u_r = GetTextureCoordFromUnitRange(rho / H, SCATTERING_TEXTURE_R_SIZE);\n  float r_mu = r * mu;\n  float discriminant = r_mu * r_mu - r * r + u_bottom_radius * u_bottom_radius;\n  float u_mu;\n  if (ray_r_mu_intersects_ground) {\n    float d = -r_mu - SafeSqrt(discriminant);\n    float d_min = r - u_bottom_radius;\n    float d_max = rho;\n    u_mu =\n      0.5 -\n      0.5 *\n        GetTextureCoordFromUnitRange(\n          d_max == d_min\n            ? 0.0\n            : (d - d_min) / (d_max - d_min),\n          SCATTERING_TEXTURE_MU_SIZE / 2\n        );\n  } else {\n    float d = -r_mu + SafeSqrt(discriminant + H * H);\n    float d_min = u_top_radius - r;\n    float d_max = rho + H;\n    u_mu =\n      0.5 +\n      0.5 *\n        GetTextureCoordFromUnitRange((d - d_min) / (d_max - d_min), SCATTERING_TEXTURE_MU_SIZE / 2);\n  }\n  float d = DistanceToTopAtmosphereBoundary(u_bottom_radius, mu_s);\n  float d_min = u_top_radius - u_bottom_radius;\n  float d_max = H;\n  float a = (d - d_min) / (d_max - d_min);\n  float D = DistanceToTopAtmosphereBoundary(u_bottom_radius, u_mu_s_min);\n  float A = (D - d_min) / (d_max - d_min);\n  float u_mu_s = GetTextureCoordFromUnitRange(\n    max(1.0 - a / A, 0.0) / (1.0 + a),\n    SCATTERING_TEXTURE_MU_S_SIZE\n  );\n  float u_nu = (nu + 1.0) / 2.0;\n  return vec4(u_nu, u_mu_s, u_mu, u_r);\n}\n\nvec2 GetIrradianceTextureUvFromRMuS(float r, float mu_s) {\n  float x_r = (r - u_bottom_radius) / (u_top_radius - u_bottom_radius);\n  float x_mu_s = mu_s * 0.5 + 0.5;\n  return vec2(\n    GetTextureCoordFromUnitRange(x_mu_s, IRRADIANCE_TEXTURE_WIDTH),\n    GetTextureCoordFromUnitRange(x_r, IRRADIANCE_TEXTURE_HEIGHT)\n  );\n}\n\nvec3 GetIrradiance(const sampler2D u_irradiance_texture, float r, float mu_s) {\n  vec2 uv = GetIrradianceTextureUvFromRMuS(r, mu_s);\n  return vec3(texture(u_irradiance_texture, uv));\n}\n\nvec3 GetExtrapolatedSingleMieScattering(const vec4 scattering) {\n  if (scattering.r <= 0.0) {\n    return vec3(0.0);\n  }\n  return scattering.rgb *\n  scattering.a /\n  scattering.r *\n  (u_rayleigh_scattering.r / u_mie_scattering.r) *\n  (u_mie_scattering / u_rayleigh_scattering);\n}\n\nvec3 GetCombinedScattering(\n  const sampler3D u_scattering_texture,\n  const sampler3D u_single_mie_scattering_texture,\n  float r,\n  float mu,\n  float mu_s,\n  float nu,\n  bool ray_r_mu_intersects_ground,\n  out vec3 single_mie_scattering\n) {\n  vec4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(r, mu, mu_s, nu, ray_r_mu_intersects_ground);\n  float tex_coord_x = uvwz.x * float(SCATTERING_TEXTURE_NU_SIZE - 1);\n  float tex_x = floor(tex_coord_x);\n  float lerp = tex_coord_x - tex_x;\n  vec3 uvw0 = vec3((tex_x + uvwz.y) / float(SCATTERING_TEXTURE_NU_SIZE), uvwz.z, uvwz.w);\n  vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / float(SCATTERING_TEXTURE_NU_SIZE), uvwz.z, uvwz.w);\n  vec4 combined_scattering =\n    texture(u_scattering_texture, uvw0) * (1.0 - lerp) + texture(u_scattering_texture, uvw1) * lerp;\n  vec3 scattering = vec3(combined_scattering);\n  single_mie_scattering = GetExtrapolatedSingleMieScattering(combined_scattering);\n  return scattering;\n}\n\nvec3 GetSkyRadiance(\n  const sampler2D u_transmittance_texture,\n  const sampler3D u_scattering_texture,\n  const sampler3D u_single_mie_scattering_texture,\n  vec3 camera,\n  const vec3 view_ray,\n  float shadow_length,\n  const vec3 sun_direction,\n  out vec3 transmittance\n) {\n  float r = length(camera);\n  float rmu = dot(camera, view_ray);\n  float distance_to_top_atmosphere_boundary =\n    -rmu - SafeSqrt(rmu * rmu - r * r + u_top_radius * u_top_radius);\n  if (distance_to_top_atmosphere_boundary > 0.0) {\n    camera = camera + view_ray * distance_to_top_atmosphere_boundary;\n    r = u_top_radius;\n    rmu += distance_to_top_atmosphere_boundary;\n  } else if (r > u_top_radius) {\n    transmittance = vec3(1.0);\n    return vec3(0.0);\n  }\n  float mu = rmu / r;\n  float mu_s = dot(camera, sun_direction) / r;\n  float nu = dot(view_ray, sun_direction);\n  bool ray_r_mu_intersects_ground = RayIntersectsGround(r, mu);\n  transmittance = ray_r_mu_intersects_ground\n    ? vec3(0.0)\n    : GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r, mu);\n  vec3 single_mie_scattering;\n  vec3 scattering;\n\n  // Hack to reduce shadow length near the horizon, as the sky with long shadow\n  // lengths should be occluded. A similar hack for the sun at the horizon is\n  // used in Bruneton\'s demo.\n  const float min_mu = 0.01;\n  const float max_mu = 0.05;\n  float shadow_length_fade =\n    1.0 - pow(min(max(1.0 - (abs(mu) - min_mu) / (max_mu - min_mu), 0.0), 1.0), 4.0);\n  shadow_length *= shadow_length_fade;\n\n  if (shadow_length == 0.0) {\n    scattering = GetCombinedScattering(\n      u_scattering_texture,\n      u_single_mie_scattering_texture,\n      r,\n      mu,\n      mu_s,\n      nu,\n      ray_r_mu_intersects_ground,\n      single_mie_scattering\n    );\n  } else {\n    float d = shadow_length;\n    float r_p = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));\n    float mu_p = (r * mu + d) / r_p;\n    float mu_s_p = (r * mu_s + d * nu) / r_p;\n    scattering = GetCombinedScattering(\n      u_scattering_texture,\n      u_single_mie_scattering_texture,\n      r_p,\n      mu_p,\n      mu_s_p,\n      nu,\n      ray_r_mu_intersects_ground,\n      single_mie_scattering\n    );\n    vec3 shadow_transmittance = GetTransmittance(\n      u_transmittance_texture,\n      r,\n      mu,\n      shadow_length,\n      ray_r_mu_intersects_ground\n    );\n    scattering = scattering * shadow_transmittance;\n    single_mie_scattering = single_mie_scattering * shadow_transmittance;\n  }\n  return scattering * RayleighPhaseFunction(nu) +\n  single_mie_scattering * MiePhaseFunction(u_mie_phase_function_g, nu);\n}\n\nvec3 GetSkyRadianceToPoint(\n  const sampler2D u_transmittance_texture,\n  const sampler3D u_scattering_texture,\n  const sampler3D u_single_mie_scattering_texture,\n  vec3 camera,\n  const vec3 point,\n  float shadow_length,\n  const vec3 sun_direction,\n  out vec3 transmittance\n) {\n  vec3 view_ray = normalize(point - camera);\n  float r = length(camera);\n  float rmu = dot(camera, view_ray);\n  float distance_to_top_atmosphere_boundary =\n    -rmu - sqrt(rmu * rmu - r * r + u_top_radius * u_top_radius);\n  if (distance_to_top_atmosphere_boundary > 0.0) {\n    camera = camera + view_ray * distance_to_top_atmosphere_boundary;\n    r = u_top_radius;\n    rmu += distance_to_top_atmosphere_boundary;\n  }\n  float mu = rmu / r;\n  float mu_s = dot(camera, sun_direction) / r;\n  float nu = dot(view_ray, sun_direction);\n  float d = length(point - camera);\n  bool ray_r_mu_intersects_ground = RayIntersectsGround(r, mu);\n\n  // Hack to avoid rendering artifacts near the horizon, due to finite\n  // atmosphere texture resolution and finite floating point precision.\n  // See: https://github.com/ebruneton/precomputed_atmospheric_scattering/pull/32\n  if (!ray_r_mu_intersects_ground) {\n    float mu_horiz = -SafeSqrt(1.0 - u_bottom_radius / r * (u_bottom_radius / r));\n    mu = max(mu, mu_horiz + 0.004);\n  }\n\n  transmittance = GetTransmittance(u_transmittance_texture, r, mu, d, ray_r_mu_intersects_ground);\n  vec3 single_mie_scattering;\n  vec3 scattering = GetCombinedScattering(\n    u_scattering_texture,\n    u_single_mie_scattering_texture,\n    r,\n    mu,\n    mu_s,\n    nu,\n    ray_r_mu_intersects_ground,\n    single_mie_scattering\n  );\n  d = max(d - shadow_length, 0.0);\n  float r_p = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));\n  float mu_p = (r * mu + d) / r_p;\n  float mu_s_p = (r * mu_s + d * nu) / r_p;\n  vec3 single_mie_scattering_p;\n  vec3 scattering_p = GetCombinedScattering(\n    u_scattering_texture,\n    u_single_mie_scattering_texture,\n    r_p,\n    mu_p,\n    mu_s_p,\n    nu,\n    ray_r_mu_intersects_ground,\n    single_mie_scattering_p\n  );\n  vec3 shadow_transmittance = transmittance;\n  if (shadow_length > 0.0) {\n    shadow_transmittance = GetTransmittance(\n      u_transmittance_texture,\n      r,\n      mu,\n      d,\n      ray_r_mu_intersects_ground\n    );\n  }\n  scattering = scattering - shadow_transmittance * scattering_p;\n  single_mie_scattering = single_mie_scattering - shadow_transmittance * single_mie_scattering_p;\n  single_mie_scattering = GetExtrapolatedSingleMieScattering(\n    vec4(scattering, single_mie_scattering.r)\n  );\n  single_mie_scattering = single_mie_scattering * smoothstep(float(0.0), float(0.01), mu_s);\n  return scattering * RayleighPhaseFunction(nu) +\n  single_mie_scattering * MiePhaseFunction(u_mie_phase_function_g, nu);\n}\n\nvec3 GetSunAndSkyIrradiance(\n  const sampler2D u_transmittance_texture,\n  const sampler2D u_irradiance_texture,\n  const vec3 point,\n  const vec3 sun_direction,\n  out vec3 sky_irradiance\n) {\n  float r = length(point);\n  float mu_s = dot(point, sun_direction) / r;\n  sky_irradiance = GetIrradiance(u_irradiance_texture, r, mu_s);\n  return u_solar_irradiance * GetTransmittanceToSun(u_transmittance_texture, r, mu_s);\n}\n\nvec3 GetSunAndSkyIrradiance(\n  const sampler2D u_transmittance_texture,\n  const sampler2D u_irradiance_texture,\n  const vec3 point,\n  const vec3 normal,\n  const vec3 sun_direction,\n  out vec3 sky_irradiance\n) {\n  float r = length(point);\n  float mu_s = dot(point, sun_direction) / r;\n  sky_irradiance =\n    GetIrradiance(u_irradiance_texture, r, mu_s) * (1.0 + dot(normal, point) / r) * 0.5;\n  return u_solar_irradiance *\n  GetTransmittanceToSun(u_transmittance_texture, r, mu_s) *\n  max(dot(normal, sun_direction), 0.0);\n}\n\nvec3 GetSolarRadiance() {\n  vec3 radiance = u_solar_irradiance / (PI * u_sun_angular_radius * u_sun_angular_radius);\n  #ifdef PHOTOMETRIC\n  radiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  #endif // PHOTOMETRIC\n  return radiance;\n}\n\nvec3 GetSkyRadiance(\n  vec3 camera,\n  vec3 view_ray,\n  float shadow_length,\n  vec3 sun_direction,\n  out vec3 transmittance\n) {\n  vec3 radiance = GetSkyRadiance(\n    u_transmittance_texture,\n    u_scattering_texture,\n    u_single_mie_scattering_texture,\n    camera,\n    view_ray,\n    shadow_length,\n    sun_direction,\n    transmittance\n  );\n  #ifdef PHOTOMETRIC\n  radiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  #endif // PHOTOMETRIC\n  return radiance;\n}\n\nvec3 GetSkyRadianceToPoint(\n  vec3 camera,\n  vec3 point,\n  float shadow_length,\n  vec3 sun_direction,\n  out vec3 transmittance\n) {\n  vec3 inscatter = GetSkyRadianceToPoint(\n    u_transmittance_texture,\n    u_scattering_texture,\n    u_single_mie_scattering_texture,\n    camera,\n    point,\n    shadow_length,\n    sun_direction,\n    transmittance\n  );\n  #ifdef PHOTOMETRIC\n  inscatter *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  #endif // PHOTOMETRIC\n  return inscatter;\n}\n\nvec3 GetSunAndSkyIrradiance(vec3 point, vec3 sun_direction, out vec3 sky_irradiance) {\n  vec3 sun_irradiance = GetSunAndSkyIrradiance(\n    u_transmittance_texture,\n    u_irradiance_texture,\n    point,\n    sun_direction,\n    sky_irradiance\n  );\n  #ifdef PHOTOMETRIC\n  sun_irradiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  sky_irradiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  #endif // PHOTOMETRIC\n  return sun_irradiance;\n}\n\nvec3 GetSunAndSkyIrradiance(vec3 point, vec3 normal, vec3 sun_direction, out vec3 sky_irradiance) {\n  vec3 sun_irradiance = GetSunAndSkyIrradiance(\n    u_transmittance_texture,\n    u_irradiance_texture,\n    point,\n    normal,\n    sun_direction,\n    sky_irradiance\n  );\n  #ifdef PHOTOMETRIC\n  sun_irradiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  sky_irradiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  #endif // PHOTOMETRIC\n  return sun_irradiance;\n}\n',we="uniform vec3 u_solar_irradiance;\nuniform float u_sun_angular_radius;\nuniform float u_bottom_radius;\nuniform float u_top_radius;\nuniform vec3 u_rayleigh_scattering;\nuniform vec3 u_mie_scattering;\nuniform float u_mie_phase_function_g;\nuniform float u_mu_s_min;\n\nuniform sampler2D u_transmittance_texture;\nuniform sampler3D u_scattering_texture;\nuniform sampler3D u_single_mie_scattering_texture;\nuniform sampler2D u_irradiance_texture;\n";var ye=Object.defineProperty,Ae=(e,t,n)=>((e,t,n)=>t in e?ye(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);const xe=["solarIrradiance","sunAngularRadius","bottomRadius","topRadius","rayleighScattering","mieScattering","miePhaseFunctionG","muSMinFloat","muSMinHalfFloat","skyRadianceToLuminance","sunRadianceToLuminance","luminousEfficiency"];const Ce=class{constructor(t){Ae(this,"solarIrradiance",new e(1.474,1.8504,1.91198)),Ae(this,"sunAngularRadius",.004675),Ae(this,"bottomRadius",636e4),Ae(this,"topRadius",642e4),Ae(this,"rayleighScattering",new e(.005802,.013558,.0331)),Ae(this,"mieScattering",new e(.003996,.003996,.003996)),Ae(this,"miePhaseFunctionG",.8),Ae(this,"muSMinFloat",Math.cos(fe(120))),Ae(this,"muSMinHalfFloat",Math.cos(fe(102))),Ae(this,"skyRadianceToLuminance",new e(114974.916437,71305.954816,65310.548555)),Ae(this,"sunRadianceToLuminance",new e(98242.786222,69954.398112,66475.012354)),Ae(this,"luminousEfficiency",new e(.2126,.7152,.0722)),Ae(this,"skyRadianceToRelativeLuminance",new e),Ae(this,"sunRadianceToRelativeLuminance",new e),function(t,n){if(null!=n)for(const i of xe){const r=n[i];null!=r&&(t[i]instanceof e?t[i].copy(r):t[i]=r)}}(this,t);const n=this.luminousEfficiency.dot(this.skyRadianceToLuminance);this.skyRadianceToRelativeLuminance.copy(this.skyRadianceToLuminance).divideScalar(n),this.sunRadianceToRelativeLuminance.copy(this.sunRadianceToLuminance).divideScalar(n)}};Ae(Ce,"DEFAULT",new Ce);let Ie=Ce;const Me=256,Ne=64,De=.001,Oe=new e;function be(e,t,n,i,r=!0){const o=n.projectOnSurface(e,Oe);return null!=o?n.getOsculatingSphereCenter(!r||o.lengthSq()<e.lengthSq()?o:e,t,i):i.setScalar(0)}const Pe="vec3 getLunarRadiance(const float moonAngularRadius) {\n  // Not a physical number but the order of 10^-6 relative to the sun may fit.\n  vec3 radiance = u_solar_irradiance * 0.000002 / (PI * moonAngularRadius * moonAngularRadius);\n  #ifdef PHOTOMETRIC\n  radiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;\n  #endif // PHOTOMETRIC\n  return radiance;\n}\n\nfloat intersectSphere(const vec3 ray, const vec3 point, const float radius) {\n  vec3 P = -point;\n  float PoR = dot(P, ray);\n  float D = dot(P, P) - radius * radius;\n  return -PoR - sqrt(PoR * PoR - D);\n}\n\nfloat orenNayarDiffuse(const vec3 L, const vec3 V, const vec3 N) {\n  float NoL = dot(N, L);\n  float NoV = dot(N, V);\n  float s = dot(L, V) - NoL * NoV;\n  float t = mix(1.0, max(NoL, NoV), step(0.0, s));\n  return max(0.0, NoL) * (0.62406015 + 0.41284404 * s / t);\n}\n\nvec3 getSkyRadiance(\n  const vec3 cameraPosition,\n  const vec3 rayDirection,\n  float shadowLength,\n  const vec3 sunDirection,\n  const vec3 moonDirection,\n  const float moonAngularRadius,\n  const float lunarRadianceScale\n) {\n  vec3 transmittance;\n  vec3 radiance = GetSkyRadiance(\n    cameraPosition,\n    rayDirection,\n    shadowLength,\n    sunDirection,\n    transmittance\n  );\n\n  // Rendering celestial objects without perspective doesn't make sense.\n  #ifdef PERSPECTIVE_CAMERA\n\n  #if defined(SUN) || defined(MOON)\n  vec3 ddx = dFdx(rayDirection);\n  vec3 ddy = dFdy(rayDirection);\n  float fragmentAngle = length(ddx + ddy) / length(rayDirection);\n  #endif // defined(SUN) || defined(MOON)\n\n  #ifdef SUN\n  float viewDotSun = dot(rayDirection, sunDirection);\n  if (viewDotSun > cos(u_sun_angular_radius)) {\n    float angle = acos(clamp(viewDotSun, -1.0, 1.0));\n    float antialias = smoothstep(u_sun_angular_radius, u_sun_angular_radius - fragmentAngle, angle);\n    radiance += transmittance * GetSolarRadiance() * antialias;\n  }\n  #endif // SUN\n\n  #ifdef MOON\n  float intersection = intersectSphere(rayDirection, moonDirection, moonAngularRadius);\n  if (intersection > 0.0) {\n    vec3 normal = normalize(moonDirection - rayDirection * intersection);\n    float diffuse = orenNayarDiffuse(-sunDirection, rayDirection, normal);\n    float viewDotMoon = dot(rayDirection, moonDirection);\n    float angle = acos(clamp(viewDotMoon, -1.0, 1.0));\n    float antialias = smoothstep(moonAngularRadius, moonAngularRadius - fragmentAngle, angle);\n    radiance +=\n      transmittance *\n      getLunarRadiance(moonAngularRadius) *\n      lunarRadianceScale *\n      diffuse *\n      antialias;\n  }\n  #endif // MOON\n\n  #endif // PERSPECTIVE_CAMERA\n\n  return radiance;\n}\n",Ue=new e,Le=new e,He=new ee,Ge={blendFunction:P.NORMAL,octEncodedNormal:!1,reconstructNormal:!1,ellipsoid:$.WGS84,correctAltitude:!0,correctGeometricError:!0,photometric:!0,sunIrradiance:!1,skyIrradiance:!1,transmittance:!0,inscatter:!0,irradianceScale:1,sky:!1,sun:!0,moon:!0,moonAngularRadius:.0045,lunarRadianceScale:1};class Fe extends U{constructor(n=new v,i,r=Ie.DEFAULT){const{blendFunction:o,normalBuffer:a=null,octEncodedNormal:s,reconstructNormal:c,irradianceTexture:u=null,scatteringTexture:l=null,transmittanceTexture:d=null,useHalfFloat:h,ellipsoid:p,correctAltitude:_,correctGeometricError:g,photometric:T,sunDirection:R,sunIrradiance:S,skyIrradiance:E,transmittance:w,inscatter:y,irradianceScale:A,sky:x,sun:C,moon:I,moonDirection:M,moonAngularRadius:N,lunarRadianceScale:D}={...Ge,...i};super("AerialPerspectiveEffect",function(e){return e.replace(Te,Re)}(ge('precision highp sampler2DArray;\n\n#include "core/depth"\n#include "core/packing"\n#include "core/transform"\n#include "core/raySphereIntersection"\n#include "core/poissonDisk"\n#include "parameters"\n#include "functions"\n#include "sky"\n\nuniform sampler2D normalBuffer;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform float bottomRadius;\nuniform vec3 ellipsoidCenter;\nuniform mat4 inverseEllipsoidMatrix;\nuniform vec3 sunDirection;\nuniform vec3 moonDirection;\nuniform float moonAngularRadius;\nuniform float lunarRadianceScale;\nuniform float irradianceScale;\nuniform float idealSphereAlpha;\n\n#ifdef HAS_COMPOSITE\nuniform sampler2D compositeBuffer;\n#endif // HAS_COMPOSITE\n\n#ifdef HAS_SHADOW\nuniform sampler2DArray shadowBuffer;\nuniform vec2 shadowIntervals[SHADOW_CASCADE_COUNT];\nuniform mat4 shadowMatrices[SHADOW_CASCADE_COUNT];\nuniform float shadowFar;\nuniform float shadowTopHeight;\nuniform float shadowRadius;\nuniform sampler3D stbnTexture;\nuniform int frame;\n#endif // HAS_SHADOW\n\n#ifdef HAS_SHADOW_LENGTH\nuniform sampler2D shadowLengthBuffer;\n#endif // HAS_SHADOW_LENGTH\n\nvarying vec3 vCameraPosition;\nvarying vec3 vRayDirection;\nvarying vec3 vEllipsoidCenter;\nvarying vec3 vGeometryEllipsoidCenter;\nvarying vec3 vEllipsoidRadiiSquared;\n\nvec3 readNormal(const vec2 uv) {\n  #ifdef OCT_ENCODED_NORMAL\n  return unpackVec2ToNormal(texture(normalBuffer, uv).xy);\n  #else // OCT_ENCODED_NORMAL\n  return 2.0 * texture(normalBuffer, uv).xyz - 1.0;\n  #endif // OCT_ENCODED_NORMAL\n}\n\nvoid correctGeometricError(inout vec3 positionECEF, inout vec3 normalECEF) {\n  // TODO: The error is pronounced at the edge of the ellipsoid due to the\n  // large difference between the sphere position and the unprojected position\n  // at the current fragment. Calculating the sphere position from the fragment\n  // UV may resolve this.\n\n  // Correct way is slerp, but this will be small-angle interpolation anyways.\n  vec3 sphereNormal = normalize(positionECEF / vEllipsoidRadiiSquared);\n  vec3 spherePosition = u_bottom_radius * sphereNormal;\n  normalECEF = mix(normalECEF, sphereNormal, idealSphereAlpha);\n  positionECEF = mix(positionECEF, spherePosition, idealSphereAlpha);\n}\n\n#if defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)\n\nvec3 getSunSkyIrradiance(\n  const vec3 positionECEF,\n  const vec3 normal,\n  const vec3 inputColor,\n  const float sunTransmittance\n) {\n  // Assume lambertian BRDF. If both SUN_IRRADIANCE and SKY_IRRADIANCE are not\n  // defined, regard the inputColor as radiance at the texel.\n  vec3 albedo = inputColor * irradianceScale * RECIPROCAL_PI;\n  vec3 skyIrradiance;\n  vec3 sunIrradiance = GetSunAndSkyIrradiance(positionECEF, normal, sunDirection, skyIrradiance);\n\n  #ifdef HAS_SHADOW\n  sunIrradiance *= sunTransmittance;\n  #endif // HAS_SHADOW\n\n  #if defined(SUN_IRRADIANCE) && defined(SKY_IRRADIANCE)\n  return albedo * (sunIrradiance + skyIrradiance);\n  #elif defined(SUN_IRRADIANCE)\n  return albedo * sunIrradiance;\n  #elif defined(SKY_IRRADIANCE)\n  return albedo * skyIrradiance;\n  #endif // defined(SUN_IRRADIANCE) && defined(SKY_IRRADIANCE)\n}\n\n#endif // defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)\n\n#if defined(TRANSMITTANCE) || defined(INSCATTER)\n\nvoid applyTransmittanceInscatter(const vec3 positionECEF, float shadowLength, inout vec3 radiance) {\n  vec3 transmittance;\n  vec3 inscatter = GetSkyRadianceToPoint(\n    vCameraPosition - vGeometryEllipsoidCenter,\n    positionECEF,\n    shadowLength,\n    sunDirection,\n    transmittance\n  );\n  #ifdef TRANSMITTANCE\n  radiance = radiance * transmittance;\n  #endif // TRANSMITTANCE\n  #ifdef INSCATTER\n  radiance = radiance + inscatter;\n  #endif // INSCATTER\n}\n\n#endif // defined(TRANSMITTANCE) || defined(INSCATTER)\n\n#ifdef HAS_SHADOW\n\nfloat getSTBN() {\n  ivec3 size = textureSize(stbnTexture, 0);\n  vec3 scale = 1.0 / vec3(size);\n  return texture(stbnTexture, vec3(gl_FragCoord.xy, float(frame % size.z)) * scale).r;\n}\n\nint getCascadeIndex(const vec3 worldPosition) {\n  vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);\n  float depth = viewZToOrthographicDepth(viewPosition.z, cameraNear, shadowFar);\n  vec2 interval;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 4; ++i) {\n    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n    interval = shadowIntervals[i];\n    if (depth >= interval.x && depth < interval.y) {\n      return UNROLLED_LOOP_INDEX;\n    }\n    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n  }\n  #pragma unroll_loop_end\n  return SHADOW_CASCADE_COUNT - 1;\n}\n\n// Reference: https://github.com/mrdoob/three.js/blob/r171/examples/jsm/csm/CSMShader.js\nint getFadedCascadeIndex(const vec3 worldPosition, const float jitter) {\n  vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);\n  float depth = viewZToOrthographicDepth(viewPosition.z, cameraNear, shadowFar);\n\n  vec2 interval;\n  float intervalCenter;\n  float closestEdge;\n  float margin;\n  int nextIndex = -1;\n  int prevIndex = -1;\n  float alpha;\n\n  #pragma unroll_loop_start\n  for (int i = 0; i < 4; ++i) {\n    #if UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n    interval = shadowIntervals[i];\n    intervalCenter = (interval.x + interval.y) * 0.5;\n    closestEdge = depth < intervalCenter ? interval.x : interval.y;\n    margin = closestEdge * closestEdge * 0.5;\n    interval += margin * vec2(-0.5, 0.5);\n\n    if (depth >= interval.x && depth < interval.y) {\n      prevIndex = nextIndex;\n      nextIndex = UNROLLED_LOOP_INDEX;\n      alpha = saturate(min(depth - interval.x, interval.y - depth) / margin);\n    }\n    #endif // UNROLLED_LOOP_INDEX < SHADOW_CASCADE_COUNT\n  }\n  #pragma unroll_loop_end\n\n  return jitter <= alpha\n    ? nextIndex\n    : prevIndex;\n}\n\nvec2 getShadowUv(const vec3 worldPosition, const int cascadeIndex) {\n  vec4 clip = shadowMatrices[cascadeIndex] * vec4(worldPosition, 1.0);\n  clip /= clip.w;\n  return clip.xy * 0.5 + 0.5;\n}\n\nfloat getDistanceToShadowTop(const vec3 positionECEF) {\n  // Distance to the top of the shadows along the sun direction, which matches\n  // the ray origin of BSM.\n  return raySphereSecondIntersection(\n    positionECEF / METER_TO_LENGTH_UNIT, // TODO: Make units consistent\n    sunDirection,\n    vec3(0.0),\n    bottomRadius + shadowTopHeight\n  );\n}\n\nfloat readShadowOpticalDepth(const vec2 uv, const float distanceToTop, const int cascadeIndex) {\n  // r: frontDepth, g: meanExtinction, b: maxOpticalDepth\n  vec4 shadow = texture(shadowBuffer, vec3(uv, float(cascadeIndex)));\n  return min(shadow.b, shadow.g * max(0.0, distanceToTop - shadow.r));\n}\n\nfloat sampleShadowOpticalDepthPCF(\n  const vec3 worldPosition,\n  const float distanceToTop,\n  const int cascadeIndex\n) {\n  vec2 uv = getShadowUv(worldPosition, cascadeIndex);\n  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n    return 0.0;\n  }\n\n  vec2 texelSize = vec2(1.0) / vec2(textureSize(shadowBuffer, 0).xy);\n  float sum = 0.0;\n  vec2 offset;\n  #pragma unroll_loop_start\n  for (int i = 0; i < 32; ++i) {\n    #if UNROLLED_LOOP_INDEX < POISSON_DISK_COUNT\n    offset = poissonDisk[i];\n    sum += readShadowOpticalDepth(\n      uv + offset * shadowRadius * texelSize,\n      distanceToTop,\n      cascadeIndex\n    );\n    #endif // UNROLLED_LOOP_INDEX < POISSON_DISK_COUNT\n  }\n  #pragma unroll_loop_end\n  return sum / float(POISSON_DISK_COUNT);\n}\n\nfloat sampleShadowOpticalDepth(\n  const vec3 worldPosition,\n  const vec3 positionECEF,\n  const float jitter\n) {\n  float distanceToTop = getDistanceToShadowTop(positionECEF);\n  if (distanceToTop <= 0.0) {\n    return 0.0;\n  }\n  int cascadeIndex = getFadedCascadeIndex(worldPosition, jitter);\n  return cascadeIndex >= 0\n    ? sampleShadowOpticalDepthPCF(worldPosition, distanceToTop, cascadeIndex)\n    : 0.0;\n}\n\n#endif // HAS_SHADOW\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  float shadowLength = 0.0;\n  #ifdef HAS_SHADOW_LENGTH\n  shadowLength = texture(shadowLengthBuffer, uv).r;\n  #endif // HAS_SHADOW_LENGTH\n\n  #ifdef HAS_COMPOSITE\n  vec4 composite = texture(compositeBuffer, uv);\n  if (composite.a == 1.0) {\n    outputColor = composite;\n    return;\n  }\n  #endif // HAS_COMPOSITE\n\n  float depth = readDepth(uv);\n  if (depth >= 1.0 - 1e-7) {\n    #ifdef SKY\n    vec3 rayDirection = normalize(vRayDirection);\n    outputColor.rgb = getSkyRadiance(\n      vCameraPosition - vEllipsoidCenter,\n      rayDirection,\n      shadowLength,\n      sunDirection,\n      moonDirection,\n      moonAngularRadius,\n      lunarRadianceScale\n    );\n    outputColor.a = 1.0;\n    #else // SKY\n    outputColor = inputColor;\n    #endif // SKY\n\n    #ifdef HAS_COMPOSITE\n    outputColor.rgb = outputColor.rgb * (1.0 - composite.a) + composite.rgb;\n    #endif // HAS_COMPOSITE\n    return;\n  }\n  depth = reverseLogDepth(depth, cameraNear, cameraFar);\n\n  // Reconstruct position and normal in world space.\n  vec3 viewPosition = screenToView(\n    uv,\n    depth,\n    getViewZ(depth),\n    projectionMatrix,\n    inverseProjectionMatrix\n  );\n  vec3 viewNormal;\n  #ifdef RECONSTRUCT_NORMAL\n  vec3 dx = dFdx(viewPosition);\n  vec3 dy = dFdy(viewPosition);\n  viewNormal = normalize(cross(dx, dy));\n  #else // RECONSTRUCT_NORMAL\n  viewNormal = readNormal(uv);\n  #endif // RECONSTRUCT_NORMAL\n\n  vec3 worldPosition = (inverseViewMatrix * vec4(viewPosition, 1.0)).xyz;\n  vec3 worldNormal = normalize(mat3(inverseViewMatrix) * viewNormal);\n  mat3 rotation = mat3(inverseEllipsoidMatrix);\n  vec3 positionECEF = rotation * worldPosition * METER_TO_LENGTH_UNIT - vGeometryEllipsoidCenter;\n  vec3 normalECEF = rotation * worldNormal;\n\n  #ifdef CORRECT_GEOMETRIC_ERROR\n  correctGeometricError(positionECEF, normalECEF);\n  #endif // CORRECT_GEOMETRIC_ERROR\n\n  #ifdef HAS_SHADOW\n  float stbn = getSTBN();\n  float opticalDepth = sampleShadowOpticalDepth(worldPosition, positionECEF, stbn);\n  float sunTransmittance = exp(-opticalDepth);\n  #else // HAS_SHADOW\n  float sunTransmittance = 1.0;\n  #endif // HAS_SHADOW\n\n  vec3 radiance;\n  #if defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)\n  radiance = getSunSkyIrradiance(positionECEF, normalECEF, inputColor.rgb, sunTransmittance);\n  #else // defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)\n  radiance = inputColor.rgb;\n  #endif // defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)\n\n  #if defined(TRANSMITTANCE) || defined(INSCATTER)\n  applyTransmittanceInscatter(positionECEF, shadowLength, radiance);\n  #endif // defined(TRANSMITTANCE) || defined(INSCATTER)\n\n  outputColor = vec4(radiance, inputColor.a);\n\n  #ifdef HAS_COMPOSITE\n  outputColor.rgb = outputColor.rgb * (1.0 - composite.a) + composite.rgb;\n  #endif // HAS_COMPOSITE\n}\n',{core:{depth:"// cSpell:words logdepthbuf\n\nfloat reverseLogDepth(const float depth, const float near, const float far) {\n  #ifdef USE_LOGDEPTHBUF\n  float d = pow(2.0, depth * log2(far + 1.0)) - 1.0;\n  float a = far / (far - near);\n  float b = far * near / (near - far);\n  return a + b / d;\n  #else // USE_LOGDEPTHBUF\n  return depth;\n  #endif // USE_LOGDEPTHBUF\n}\n\nfloat linearizeDepth(const float depth, const float near, const float far) {\n  float ndc = depth * 2.0 - 1.0;\n  return 2.0 * near * far / (far + near - ndc * (far - near));\n}\n",packing:"// Reference: https://jcgt.org/published/0003/02/01/paper.pdf\n\nvec2 signNotZero(vec2 v) {\n  return vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);\n}\n\nvec2 packNormalToVec2(vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return v.z <= 0.0\n    ? (1.0 - abs(p.yx)) * signNotZero(p)\n    : p;\n}\n\nvec3 unpackVec2ToNormal(vec2 e) {\n  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\n  if (v.z < 0.0) {\n    v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n  }\n  return normalize(v);\n}\n",transform:"vec3 screenToView(\n  const vec2 uv,\n  const float depth,\n  const float viewZ,\n  const mat4 projectionMatrix,\n  const mat4 inverseProjectionMatrix\n) {\n  vec4 clip = vec4(vec3(uv, depth) * 2.0 - 1.0, 1.0);\n  float clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];\n  clip *= clipW;\n  return (inverseProjectionMatrix * clip).xyz;\n}\n",raySphereIntersection:Se,poissonDisk:"// Taken from: https://developer.download.nvidia.com/whitepapers/2008/PCSS_Integration.pdf\nconst vec2 poissonDisk[16] = vec2[16](\n  vec2(-0.94201624, -0.39906216),\n  vec2(0.94558609, -0.76890725),\n  vec2(-0.094184101, -0.9293887),\n  vec2(0.34495938, 0.2938776),\n  vec2(-0.91588581, 0.45771432),\n  vec2(-0.81544232, -0.87912464),\n  vec2(-0.38277543, 0.27676845),\n  vec2(0.97484398, 0.75648379),\n  vec2(0.44323325, -0.97511554),\n  vec2(0.53742981, -0.4737342),\n  vec2(-0.26496911, -0.41893023),\n  vec2(0.79197514, 0.19090188),\n  vec2(-0.2418884, 0.99706507),\n  vec2(-0.81409955, 0.9143759),\n  vec2(0.19984126, 0.78641367),\n  vec2(0.14383161, -0.1410079)\n);\n\n#define POISSON_DISK_COUNT (16)\n"},parameters:we,functions:Ee,sky:Pe})),{blendFunction:o,vertexShader:ge("uniform mat4 inverseViewMatrix;\nuniform mat4 inverseProjectionMatrix;\nuniform vec3 cameraPosition;\nuniform vec3 ellipsoidCenter;\nuniform mat4 inverseEllipsoidMatrix;\nuniform vec3 altitudeCorrection;\nuniform vec3 ellipsoidRadii;\nuniform float idealSphereAlpha;\n\nvarying vec3 vCameraPosition;\nvarying vec3 vRayDirection;\nvarying vec3 vEllipsoidCenter;\nvarying vec3 vGeometryEllipsoidCenter;\nvarying vec3 vEllipsoidRadiiSquared;\n\nvoid getCameraRay(out vec3 origin, out vec3 direction) {\n  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column\n\n  if (isPerspective) {\n    // Calculate the camera ray for a perspective camera.\n    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);\n    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);\n    origin = cameraPosition;\n    direction = worldDirection.xyz;\n  } else {\n    // Unprojected points to calculate direction.\n    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);\n    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);\n    nearPoint /= nearPoint.w;\n    farPoint /= farPoint.w;\n\n    // Calculate world values.\n    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);\n    vec4 worldOrigin = inverseViewMatrix * nearPoint;\n\n    // Outputs\n    direction = worldDirection.xyz;\n    origin = worldOrigin.xyz;\n  }\n}\n\nvoid mainSupport() {\n  vec3 direction, origin;\n  getCameraRay(origin, direction);\n\n  mat3 rotation = mat3(inverseEllipsoidMatrix);\n  vCameraPosition = rotation * origin.xyz * METER_TO_LENGTH_UNIT;\n  vRayDirection = rotation * direction.xyz;\n\n  vEllipsoidCenter = (ellipsoidCenter + altitudeCorrection) * METER_TO_LENGTH_UNIT;\n  #ifdef CORRECT_GEOMETRIC_ERROR\n  // Gradually turn off altitude correction for aerial perspective as geometric\n  // error correction takes effect.\n  // See: https://github.com/takram-design-engineering/three-geospatial/pull/23#issuecomment-2542914656\n  vGeometryEllipsoidCenter =\n    (ellipsoidCenter + mix(altitudeCorrection, vec3(0.0), idealSphereAlpha)) * METER_TO_LENGTH_UNIT;\n  #else\n  vGeometryEllipsoidCenter = vEllipsoidCenter;\n  #endif // CORRECT_GEOMETRIC_ERROR\n\n  vec3 radii = ellipsoidRadii * METER_TO_LENGTH_UNIT;\n  vEllipsoidRadiiSquared = radii * radii;\n}\n",{parameters:we}),attributes:L.DEPTH,uniforms:new Map(Object.entries({normalBuffer:new m(a),projectionMatrix:new m(new t),viewMatrix:new m(new t),inverseProjectionMatrix:new m(new t),inverseViewMatrix:new m(new t),cameraPosition:new m(new e),bottomRadius:new m(r.bottomRadius),ellipsoidRadii:new m(new e),ellipsoidCenter:new m(new e),inverseEllipsoidMatrix:new m(new t),altitudeCorrection:new m(new e),sunDirection:new m((null==R?void 0:R.clone())??new e),irradianceScale:new m(A),idealSphereAlpha:new m(0),moonDirection:new m((null==M?void 0:M.clone())??new e),moonAngularRadius:new m(N),lunarRadianceScale:new m(D),compositeBuffer:new m(null),shadowBuffer:new m(null),shadowMapSize:new m(new f),shadowIntervals:new m([]),shadowMatrices:new m([]),shadowFar:new m(0),shadowTopHeight:new m(0),shadowRadius:new m(3),stbnTexture:new m(null),frame:new m(0),shadowLengthBuffer:new m(null),u_solar_irradiance:new m(r.solarIrradiance),u_sun_angular_radius:new m(r.sunAngularRadius),u_bottom_radius:new m(r.bottomRadius*De),u_top_radius:new m(r.topRadius*De),u_rayleigh_scattering:new m(r.rayleighScattering),u_mie_scattering:new m(r.mieScattering),u_mie_phase_function_g:new m(r.miePhaseFunctionG),u_mu_s_min:new m(0),u_irradiance_texture:new m(u),u_scattering_texture:new m(l),u_single_mie_scattering_texture:new m(l),u_transmittance_texture:new m(d)})),defines:new Map([["TRANSMITTANCE_TEXTURE_WIDTH",`${Me}`],["TRANSMITTANCE_TEXTURE_HEIGHT",`${Ne}`],["SCATTERING_TEXTURE_R_SIZE","32"],["SCATTERING_TEXTURE_MU_SIZE","128"],["SCATTERING_TEXTURE_MU_S_SIZE","32"],["SCATTERING_TEXTURE_NU_SIZE","8"],["IRRADIANCE_TEXTURE_WIDTH","64"],["IRRADIANCE_TEXTURE_HEIGHT","16"],["METER_TO_LENGTH_UNIT","float(0.001)"],["SUN_SPECTRAL_RADIANCE_TO_LUMINANCE",`vec3(${r.sunRadianceToRelativeLuminance.toArray().join(",")})`],["SKY_SPECTRAL_RADIANCE_TO_LUMINANCE",`vec3(${r.skyRadianceToRelativeLuminance.toArray().join(",")})`]])}),Ae(this,"_ellipsoid"),Ae(this,"ellipsoidMatrix",new t),Ae(this,"correctAltitude"),this.camera=n,this.atmosphere=r,this.octEncodedNormal=s,this.reconstructNormal=c,this.useHalfFloat=!0===h,this.ellipsoid=p,this.correctAltitude=_,this.correctGeometricError=g,this.photometric=T,this.sunIrradiance=S,this.skyIrradiance=E,this.transmittance=w,this.inscatter=y,this.sky=x,this.sun=C,this.moon=I}get mainCamera(){return this.camera}set mainCamera(e){this.camera=e}update(e,t,n){const i=this.uniforms,r=i.get("projectionMatrix"),o=i.get("viewMatrix"),a=i.get("inverseProjectionMatrix"),s=i.get("inverseViewMatrix"),c=this.camera;r.value.copy(c.projectionMatrix),o.value.copy(c.matrixWorldInverse),a.value.copy(c.projectionMatrixInverse),s.value.copy(c.matrixWorld);const u=c.getWorldPosition(i.get("cameraPosition").value),l=i.get("inverseEllipsoidMatrix").value.copy(this.ellipsoidMatrix).invert(),d=Ue.copy(u).applyMatrix4(l).sub(i.get("ellipsoidCenter").value);try{const e=He.setFromECEF(d).height,t=Le.set(0,this.ellipsoid.maximumRadius,-e).applyMatrix4(c.projectionMatrix);i.get("idealSphereAlpha").value=function(e){return Math.min(Math.max(e,0),1)}(ve(t.y,41.5,13.8,0,1))}catch{return}const h=i.get("altitudeCorrection");this.correctAltitude?be(d,this.atmosphere.bottomRadius,this.ellipsoid,h.value):h.value.setScalar(0),++this.uniforms.get("frame").value}get normalBuffer(){return this.uniforms.get("normalBuffer").value}set normalBuffer(e){this.uniforms.get("normalBuffer").value=e}get octEncodedNormal(){return this.defines.has("OCT_ENCODED_NORMAL")}set octEncodedNormal(e){e!==this.octEncodedNormal&&(e?this.defines.set("OCT_ENCODED_NORMAL","1"):this.defines.delete("OCT_ENCODED_NORMAL"),this.setChanged())}get reconstructNormal(){return this.defines.has("RECONSTRUCT_NORMAL")}set reconstructNormal(e){e!==this.reconstructNormal&&(e?this.defines.set("RECONSTRUCT_NORMAL","1"):this.defines.delete("RECONSTRUCT_NORMAL"),this.setChanged())}get irradianceTexture(){return this.uniforms.get("u_irradiance_texture").value}set irradianceTexture(e){this.uniforms.get("u_irradiance_texture").value=e}get scatteringTexture(){return this.uniforms.get("u_scattering_texture").value}set scatteringTexture(e){this.uniforms.get("u_scattering_texture").value=e,this.uniforms.get("u_single_mie_scattering_texture").value=e}get transmittanceTexture(){return this.uniforms.get("u_transmittance_texture").value}set transmittanceTexture(e){this.uniforms.get("u_transmittance_texture").value=e}get useHalfFloat(){return this.uniforms.get("u_mu_s_min").value===this.atmosphere.muSMinHalfFloat}set useHalfFloat(e){this.uniforms.get("u_mu_s_min").value=e?this.atmosphere.muSMinHalfFloat:this.atmosphere.muSMinFloat}get ellipsoid(){return this._ellipsoid}set ellipsoid(e){this._ellipsoid=e,this.uniforms.get("ellipsoidRadii").value.copy(e.radii)}get ellipsoidCenter(){return this.uniforms.get("ellipsoidCenter").value}get correctGeometricError(){return this.defines.has("CORRECT_GEOMETRIC_ERROR")}set correctGeometricError(e){e!==this.correctGeometricError&&(e?this.defines.set("CORRECT_GEOMETRIC_ERROR","1"):this.defines.delete("CORRECT_GEOMETRIC_ERROR"),this.setChanged())}get photometric(){return this.defines.has("PHOTOMETRIC")}set photometric(e){e!==this.photometric&&(e?this.defines.set("PHOTOMETRIC","1"):this.defines.delete("PHOTOMETRIC"),this.setChanged())}get sunDirection(){return this.uniforms.get("sunDirection").value}get sunIrradiance(){return this.defines.has("SUN_IRRADIANCE")}set sunIrradiance(e){e!==this.sunIrradiance&&(e?this.defines.set("SUN_IRRADIANCE","1"):this.defines.delete("SUN_IRRADIANCE"),this.setChanged())}get skyIrradiance(){return this.defines.has("SKY_IRRADIANCE")}set skyIrradiance(e){e!==this.skyIrradiance&&(e?this.defines.set("SKY_IRRADIANCE","1"):this.defines.delete("SKY_IRRADIANCE"),this.setChanged())}get transmittance(){return this.defines.has("TRANSMITTANCE")}set transmittance(e){e!==this.transmittance&&(e?this.defines.set("TRANSMITTANCE","1"):this.defines.delete("TRANSMITTANCE"),this.setChanged())}get inscatter(){return this.defines.has("INSCATTER")}set inscatter(e){e!==this.inscatter&&(e?this.defines.set("INSCATTER","1"):this.defines.delete("INSCATTER"),this.setChanged())}get irradianceScale(){return this.uniforms.get("irradianceScale").value}set irradianceScale(e){this.uniforms.get("irradianceScale").value=e}get sky(){return this.defines.has("SKY")}set sky(e){e!==this.sky&&(e?this.defines.set("SKY","1"):this.defines.delete("SKY"),this.setChanged())}get sun(){return this.defines.has("SUN")}set sun(e){e!==this.sun&&(e?this.defines.set("SUN","1"):this.defines.delete("SUN"),this.setChanged())}get moon(){return this.defines.has("MOON")}set moon(e){e!==this.moon&&(e?this.defines.set("MOON","1"):this.defines.delete("MOON"),this.setChanged())}get moonDirection(){return this.uniforms.get("moonDirection").value}get moonAngularRadius(){return this.uniforms.get("moonAngularRadius").value}set moonAngularRadius(e){this.uniforms.get("moonAngularRadius").value=e}get lunarRadianceScale(){return this.uniforms.get("lunarRadianceScale").value}set lunarRadianceScale(e){this.uniforms.get("lunarRadianceScale").value=e}setUniform(e,t){t instanceof m?this.uniforms.set(e,t):this.uniforms.get(e).value=t}set composite(e){null!=e?(this.defines.set("HAS_COMPOSITE","1"),this.setUniform("compositeBuffer",e.map)):(this.defines.delete("HAS_COMPOSITE"),this.uniforms.get("compositeBuffer").value=null),this.setChanged()}get stbnTexture(){return this.uniforms.get("stbnTexture").value}set stbnTexture(e){this.uniforms.get("stbnTexture").value=e}set shadow(e){null!=e?(this.defines.set("HAS_SHADOW","1"),this.defines.set("SHADOW_CASCADE_COUNT",`${e.intervals.length}`),this.setUniform("shadowBuffer",e.map),this.uniforms.get("shadowMapSize").value.copy(e.mapSize),this.uniforms.get("shadowIntervals").value=e.intervals,this.uniforms.get("shadowMatrices").value=e.matrices,this.setUniform("shadowFar",e.far),this.setUniform("shadowTopHeight",e.topHeight)):(this.defines.delete("HAS_SHADOW"),this.uniforms.get("shadowBuffer").value=null),this.setChanged()}get shadowRadius(){return this.uniforms.get("shadowRadius").value}set shadowRadius(e){this.uniforms.get("shadowRadius").value=e}set shadowLength(e){null!=e?(this.defines.set("HAS_SHADOW_LENGTH","1"),this.setUniform("shadowLengthBuffer",e.map)):(this.defines.delete("HAS_SHADOW_LENGTH"),this.uniforms.get("shadowLengthBuffer").value=null),this.setChanged()}}const ze=new e;const Be={useHalfFloat:!1,ellipsoid:$.WGS84,correctAltitude:!0,photometric:!0,renderTargetCount:1};class ke extends y{constructor(n,i=Ie.DEFAULT){const{irradianceTexture:r=null,scatteringTexture:o=null,transmittanceTexture:a=null,useHalfFloat:s,ellipsoid:c,correctAltitude:u,photometric:l,sunDirection:d,sunAngularRadius:h,renderTargetCount:f,...v}={...Be,...n};super({toneMapped:!1,depthWrite:!1,depthTest:!1,...v,uniforms:{cameraPosition:new m(new e),ellipsoidCenter:new m(new e),inverseEllipsoidMatrix:new m(new t),altitudeCorrection:new m(new e),sunDirection:new m((null==d?void 0:d.clone())??new e),u_solar_irradiance:new m(i.solarIrradiance),u_sun_angular_radius:new m(h??i.sunAngularRadius),u_bottom_radius:new m(i.bottomRadius*De),u_top_radius:new m(i.topRadius*De),u_rayleigh_scattering:new m(i.rayleighScattering),u_mie_scattering:new m(i.mieScattering),u_mie_phase_function_g:new m(i.miePhaseFunctionG),u_mu_s_min:new m(0),u_irradiance_texture:new m(r),u_scattering_texture:new m(o),u_single_mie_scattering_texture:new m(o),u_transmittance_texture:new m(a),...v.uniforms},defines:{PI:`${Math.PI}`,TRANSMITTANCE_TEXTURE_WIDTH:`${Me}`,TRANSMITTANCE_TEXTURE_HEIGHT:`${Ne}`,SCATTERING_TEXTURE_R_SIZE:"32",SCATTERING_TEXTURE_MU_SIZE:"128",SCATTERING_TEXTURE_MU_S_SIZE:"32",SCATTERING_TEXTURE_NU_SIZE:"8",IRRADIANCE_TEXTURE_WIDTH:"64",IRRADIANCE_TEXTURE_HEIGHT:"16",METER_TO_LENGTH_UNIT:"float(0.001)",SUN_SPECTRAL_RADIANCE_TO_LUMINANCE:`vec3(${i.sunRadianceToRelativeLuminance.toArray().join(",")})`,SKY_SPECTRAL_RADIANCE_TO_LUMINANCE:`vec3(${i.skyRadianceToRelativeLuminance.toArray().join(",")})`,...v.defines}}),Ae(this,"ellipsoid"),Ae(this,"ellipsoidMatrix",new t),Ae(this,"correctAltitude"),Ae(this,"_renderTargetCount"),this.atmosphere=i,this.atmosphere=i,this.useHalfFloat=s,this.ellipsoid=c,this.correctAltitude=u,this.photometric=l,this.renderTargetCount=f}copyCameraSettings(e){const t=this.uniforms,n=e.getWorldPosition(t.cameraPosition.value),i=t.inverseEllipsoidMatrix.value.copy(this.ellipsoidMatrix).invert(),r=ze.copy(n).applyMatrix4(i).sub(t.ellipsoidCenter.value),o=t.altitudeCorrection.value;this.correctAltitude?be(r,this.atmosphere.bottomRadius,this.ellipsoid,o):o.setScalar(0)}onBeforeCompile(e,t){e.fragmentShader=function(e,t){let n="",i="";for(let e=1;e<t;++e)n+=`layout(location = ${e}) out float renderTarget${e};\n`,i+=`renderTarget${e} = 0.0;\n`;return e.replace("#include <mrt_layout>",n).replace("#include <mrt_output>",i)}(e.fragmentShader,this.renderTargetCount)}onBeforeRender(e,t,n,i,r,o){this.copyCameraSettings(n)}get irradianceTexture(){return this.uniforms.u_irradiance_texture.value}set irradianceTexture(e){this.uniforms.u_irradiance_texture.value=e}get scatteringTexture(){return this.uniforms.u_scattering_texture.value}set scatteringTexture(e){this.uniforms.u_scattering_texture.value=e,this.uniforms.u_single_mie_scattering_texture.value=e}get transmittanceTexture(){return this.uniforms.u_transmittance_texture.value}set transmittanceTexture(e){this.uniforms.u_transmittance_texture.value=e}get useHalfFloat(){return this.uniforms.u_mu_s_min.value===this.atmosphere.muSMinHalfFloat}set useHalfFloat(e){this.uniforms.u_mu_s_min.value=e?this.atmosphere.muSMinHalfFloat:this.atmosphere.muSMinFloat}get ellipsoidCenter(){return this.uniforms.ellipsoidCenter.value}get photometric(){return null!=this.defines.PHOTOMETRIC}set photometric(e){e!==this.photometric&&(e?this.defines.PHOTOMETRIC="1":delete this.defines.PHOTOMETRIC,this.needsUpdate=!0)}get sunDirection(){return this.uniforms.sunDirection.value}get sunAngularRadius(){return this.uniforms.u_sun_angular_radius.value}set sunAngularRadius(e){this.uniforms.u_sun_angular_radius.value=e}get renderTargetCount(){return this._renderTargetCount}set renderTargetCount(e){e!==this.renderTargetCount&&(this._renderTargetCount=e,this.needsUpdate=!0)}}
/**
    @preserve

    Astronomy library for JavaScript (browser and Node.js).
    https://github.com/cosinekitty/astronomy

    MIT License

    Copyright (c) 2019-2023 Don Cross <cosinekitty@gmail.com>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
/**
 * @fileoverview Astronomy calculation library for browser scripting and Node.js.
 * @author Don Cross <cosinekitty@gmail.com>
 * @license MIT
 */const We=173.1446326846693,Ve=.017453292519943295,je=new Date("2000-01-01T12:00:00Z"),qe=2*Math.PI,Ye=180/Math.PI*3600,Xe=484813681109536e-20,Ke=1296e3,$e=4263520978299708e-20,Ze=81.30056,Je=.0002959122082855911,Qe=2.825345909524226e-7,et=8.459715185680659e-8,tt=1.292024916781969e-8,nt=1.524358900784276e-8;function it(e){if(!Number.isFinite(e))throw console.trace(),`Value is not a finite number: ${e}`;return e}function rt(e){return e-Math.floor(e)}var ot;!function(e){e.Sun="Sun",e.Moon="Moon",e.Mercury="Mercury",e.Venus="Venus",e.Earth="Earth",e.Mars="Mars",e.Jupiter="Jupiter",e.Saturn="Saturn",e.Uranus="Uranus",e.Neptune="Neptune",e.Pluto="Pluto",e.SSB="SSB",e.EMB="EMB",e.Star1="Star1",e.Star2="Star2",e.Star3="Star3",e.Star4="Star4",e.Star5="Star5",e.Star6="Star6",e.Star7="Star7",e.Star8="Star8"}(ot||(ot={}));const at=[ot.Star1,ot.Star2,ot.Star3,ot.Star4,ot.Star5,ot.Star6,ot.Star7,ot.Star8],st=[{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0},{ra:0,dec:0,dist:0}];function ct(e){const t=function(e){const t=at.indexOf(e);return t>=0?st[t]:null}(e);return t&&t.dist>0?t:null}var ut;!function(e){e[e.From2000=0]="From2000",e[e.Into2000=1]="Into2000"}(ut||(ut={}));const lt={Mercury:[[[[4.40250710144,0,0],[.40989414977,1.48302034195,26087.9031415742],[.050462942,4.47785489551,52175.8062831484],[.00855346844,1.16520322459,78263.70942472259],[.00165590362,4.11969163423,104351.61256629678],[.00034561897,.77930768443,130439.51570787099],[7583476e-11,3.71348404924,156527.41884944518]],[[26087.90313685529,0,0],[.01131199811,6.21874197797,26087.9031415742],[.00292242298,3.04449355541,52175.8062831484],[.00075775081,6.08568821653,78263.70942472259],[.00019676525,2.80965111777,104351.61256629678]]],[[[.11737528961,1.98357498767,26087.9031415742],[.02388076996,5.03738959686,52175.8062831484],[.01222839532,3.14159265359,0],[.0054325181,1.79644363964,78263.70942472259],[.0012977877,4.83232503958,104351.61256629678],[.00031866927,1.58088495658,130439.51570787099],[7963301e-11,4.60972126127,156527.41884944518]],[[.00274646065,3.95008450011,26087.9031415742],[.00099737713,3.14159265359,0]]],[[[.39528271651,0,0],[.07834131818,6.19233722598,26087.9031415742],[.00795525558,2.95989690104,52175.8062831484],[.00121281764,6.01064153797,78263.70942472259],[.00021921969,2.77820093972,104351.61256629678],[4354065e-11,5.82894543774,130439.51570787099]],[[.0021734774,4.65617158665,26087.9031415742],[.00044141826,1.42385544001,52175.8062831484]]]],Venus:[[[[3.17614666774,0,0],[.01353968419,5.59313319619,10213.285546211],[.00089891645,5.30650047764,20426.571092422],[5477194e-11,4.41630661466,7860.4193924392],[3455741e-11,2.6996444782,11790.6290886588],[2372061e-11,2.99377542079,3930.2096962196],[1317168e-11,5.18668228402,26.2983197998],[1664146e-11,4.25018630147,1577.3435424478],[1438387e-11,4.15745084182,9683.5945811164],[1200521e-11,6.15357116043,30639.856638633]],[[10213.28554621638,0,0],[.00095617813,2.4640651111,10213.285546211],[7787201e-11,.6247848222,20426.571092422]]],[[[.05923638472,.26702775812,10213.285546211],[.00040107978,1.14737178112,20426.571092422],[.00032814918,3.14159265359,0]],[[.00287821243,1.88964962838,10213.285546211]]],[[[.72334820891,0,0],[.00489824182,4.02151831717,10213.285546211],[1658058e-11,4.90206728031,20426.571092422],[1378043e-11,1.12846591367,11790.6290886588],[1632096e-11,2.84548795207,7860.4193924392],[498395e-11,2.58682193892,9683.5945811164],[221985e-11,2.01346696541,19367.1891622328],[237454e-11,2.55136053886,15720.8387848784]],[[.00034551041,.89198706276,10213.285546211]]]],Earth:[[[[1.75347045673,0,0],[.03341656453,4.66925680415,6283.0758499914],[.00034894275,4.62610242189,12566.1516999828],[3417572e-11,2.82886579754,3.523118349],[3497056e-11,2.74411783405,5753.3848848968],[3135899e-11,3.62767041756,77713.7714681205],[2676218e-11,4.41808345438,7860.4193924392],[2342691e-11,6.13516214446,3930.2096962196],[1273165e-11,2.03709657878,529.6909650946],[1324294e-11,.74246341673,11506.7697697936],[901854e-11,2.04505446477,26.2983197998],[1199167e-11,1.10962946234,1577.3435424478],[857223e-11,3.50849152283,398.1490034082],[779786e-11,1.17882681962,5223.6939198022],[99025e-10,5.23268072088,5884.9268465832],[753141e-11,2.53339052847,5507.5532386674],[505267e-11,4.58292599973,18849.2275499742],[492392e-11,4.20505711826,775.522611324],[356672e-11,2.91954114478,.0673103028],[284125e-11,1.89869240932,796.2980068164],[242879e-11,.34481445893,5486.777843175],[317087e-11,5.84901948512,11790.6290886588],[271112e-11,.31486255375,10977.078804699],[206217e-11,4.80646631478,2544.3144198834],[205478e-11,1.86953770281,5573.1428014331],[202318e-11,2.45767790232,6069.7767545534],[126225e-11,1.08295459501,20.7753954924],[155516e-11,.83306084617,213.299095438]],[[6283.0758499914,0,0],[.00206058863,2.67823455808,6283.0758499914],[4303419e-11,2.63512233481,12566.1516999828]],[[8721859e-11,1.07253635559,6283.0758499914]]],[[],[[.00227777722,3.4137662053,6283.0758499914],[3805678e-11,3.37063423795,12566.1516999828]]],[[[1.00013988784,0,0],[.01670699632,3.09846350258,6283.0758499914],[.00013956024,3.05524609456,12566.1516999828],[308372e-10,5.19846674381,77713.7714681205],[1628463e-11,1.17387558054,5753.3848848968],[1575572e-11,2.84685214877,7860.4193924392],[924799e-11,5.45292236722,11506.7697697936],[542439e-11,4.56409151453,3930.2096962196],[47211e-10,3.66100022149,5884.9268465832],[8.5831e-7,1.27079125277,161000.6857376741],[5.7056e-7,2.01374292245,83996.84731811189],[5.5736e-7,5.2415979917,71430.69561812909],[174844e-11,3.01193636733,18849.2275499742],[243181e-11,4.2734953079,11790.6290886588]],[[.00103018607,1.10748968172,6283.0758499914],[1721238e-11,1.06442300386,12566.1516999828]],[[4359385e-11,5.78455133808,6283.0758499914]]]],Mars:[[[[6.20347711581,0,0],[.18656368093,5.0503710027,3340.6124266998],[.01108216816,5.40099836344,6681.2248533996],[.00091798406,5.75478744667,10021.8372800994],[.00027744987,5.97049513147,3.523118349],[.00010610235,2.93958560338,2281.2304965106],[.00012315897,.84956094002,2810.9214616052],[8926784e-11,4.15697846427,.0172536522],[8715691e-11,6.11005153139,13362.4497067992],[6797556e-11,.36462229657,398.1490034082],[7774872e-11,3.33968761376,5621.8429232104],[3575078e-11,1.6618650571,2544.3144198834],[4161108e-11,.22814971327,2942.4634232916],[3075252e-11,.85696614132,191.4482661116],[2628117e-11,.64806124465,3337.0893083508],[2937546e-11,6.07893711402,.0673103028],[2389414e-11,5.03896442664,796.2980068164],[2579844e-11,.02996736156,3344.1355450488],[1528141e-11,1.14979301996,6151.533888305],[1798806e-11,.65634057445,529.6909650946],[1264357e-11,3.62275122593,5092.1519581158],[1286228e-11,3.06796065034,2146.1654164752],[1546404e-11,2.91579701718,1751.539531416],[1024902e-11,3.69334099279,8962.4553499102],[891566e-11,.18293837498,16703.062133499],[858759e-11,2.4009381194,2914.0142358238],[832715e-11,2.46418619474,3340.5951730476],[83272e-10,4.49495782139,3340.629680352],[712902e-11,3.66335473479,1059.3819301892],[748723e-11,3.82248614017,155.4203994342],[723861e-11,.67497311481,3738.761430108],[635548e-11,2.92182225127,8432.7643848156],[655162e-11,.48864064125,3127.3133312618],[550474e-11,3.81001042328,.9803210682],[55275e-10,4.47479317037,1748.016413067],[425966e-11,.55364317304,6283.0758499914],[415131e-11,.49662285038,213.299095438],[472167e-11,3.62547124025,1194.4470102246],[306551e-11,.38052848348,6684.7479717486],[312141e-11,.99853944405,6677.7017350506],[293198e-11,4.22131299634,20.7753954924],[302375e-11,4.48618007156,3532.0606928114],[274027e-11,.54222167059,3340.545116397],[281079e-11,5.88163521788,1349.8674096588],[231183e-11,1.28242156993,3870.3033917944],[283602e-11,5.7688543494,3149.1641605882],[236117e-11,5.75503217933,3333.498879699],[274033e-11,.13372524985,3340.6797370026],[299395e-11,2.78323740866,6254.6266625236]],[[3340.61242700512,0,0],[.01457554523,3.60433733236,3340.6124266998],[.00168414711,3.92318567804,6681.2248533996],[.00020622975,4.26108844583,10021.8372800994],[3452392e-11,4.7321039319,3.523118349],[2586332e-11,4.60670058555,13362.4497067992],[841535e-11,4.45864030426,2281.2304965106]],[[.00058152577,2.04961712429,3340.6124266998],[.00013459579,2.45738706163,6681.2248533996]]],[[[.03197134986,3.76832042431,3340.6124266998],[.00298033234,4.10616996305,6681.2248533996],[.00289104742,0,0],[.00031365539,4.4465105309,10021.8372800994],[34841e-9,4.7881254926,13362.4497067992]],[[.00217310991,6.04472194776,3340.6124266998],[.00020976948,3.14159265359,0],[.00012834709,1.60810667915,6681.2248533996]]],[[[1.53033488271,0,0],[.1418495316,3.47971283528,3340.6124266998],[.00660776362,3.81783443019,6681.2248533996],[.00046179117,4.15595316782,10021.8372800994],[8109733e-11,5.55958416318,2810.9214616052],[7485318e-11,1.77239078402,5621.8429232104],[5523191e-11,1.3643630377,2281.2304965106],[382516e-10,4.49407183687,13362.4497067992],[2306537e-11,.09081579001,2544.3144198834],[1999396e-11,5.36059617709,3337.0893083508],[2484394e-11,4.9254563992,2942.4634232916],[1960195e-11,4.74249437639,3344.1355450488],[1167119e-11,2.11260868341,5092.1519581158],[1102816e-11,5.00908403998,398.1490034082],[899066e-11,4.40791133207,529.6909650946],[992252e-11,5.83861961952,6151.533888305],[807354e-11,2.10217065501,1059.3819301892],[797915e-11,3.44839203899,796.2980068164],[740975e-11,1.49906336885,2146.1654164752]],[[.01107433345,2.03250524857,3340.6124266998],[.00103175887,2.37071847807,6681.2248533996],[128772e-9,0,0],[.0001081588,2.70888095665,10021.8372800994]],[[.00044242249,.47930604954,3340.6124266998],[8138042e-11,.86998389204,6681.2248533996]]]],Jupiter:[[[[.59954691494,0,0],[.09695898719,5.06191793158,529.6909650946],[.00573610142,1.44406205629,7.1135470008],[.00306389205,5.41734730184,1059.3819301892],[.00097178296,4.14264726552,632.7837393132],[.00072903078,3.64042916389,522.5774180938],[.00064263975,3.41145165351,103.0927742186],[.00039806064,2.29376740788,419.4846438752],[.00038857767,1.27231755835,316.3918696566],[.00027964629,1.7845459182,536.8045120954],[.0001358973,5.7748104079,1589.0728952838],[8246349e-11,3.5822792584,206.1855484372],[8768704e-11,3.63000308199,949.1756089698],[7368042e-11,5.0810119427,735.8765135318],[626315e-10,.02497628807,213.299095438],[6114062e-11,4.51319998626,1162.4747044078],[4905396e-11,1.32084470588,110.2063212194],[5305285e-11,1.30671216791,14.2270940016],[5305441e-11,4.18625634012,1052.2683831884],[4647248e-11,4.69958103684,3.9321532631],[3045023e-11,4.31676431084,426.598190876],[2609999e-11,1.56667394063,846.0828347512],[2028191e-11,1.06376530715,3.1813937377],[1764763e-11,2.14148655117,1066.49547719],[1722972e-11,3.88036268267,1265.5674786264],[1920945e-11,.97168196472,639.897286314],[1633223e-11,3.58201833555,515.463871093],[1431999e-11,4.29685556046,625.6701923124],[973272e-11,4.09764549134,95.9792272178]],[[529.69096508814,0,0],[.00489503243,4.2208293947,529.6909650946],[.00228917222,6.02646855621,7.1135470008],[.00030099479,4.54540782858,1059.3819301892],[.0002072092,5.45943156902,522.5774180938],[.00012103653,.16994816098,536.8045120954],[6067987e-11,4.42422292017,103.0927742186],[5433968e-11,3.98480737746,419.4846438752],[4237744e-11,5.89008707199,14.2270940016]],[[.00047233601,4.32148536482,7.1135470008],[.00030649436,2.929777887,529.6909650946],[.00014837605,3.14159265359,0]]],[[[.02268615702,3.55852606721,529.6909650946],[.00109971634,3.90809347197,1059.3819301892],[.00110090358,0,0],[8101428e-11,3.60509572885,522.5774180938],[6043996e-11,4.25883108339,1589.0728952838],[6437782e-11,.30627119215,536.8045120954]],[[.00078203446,1.52377859742,529.6909650946]]],[[[5.20887429326,0,0],[.25209327119,3.49108639871,529.6909650946],[.00610599976,3.84115365948,1059.3819301892],[.00282029458,2.57419881293,632.7837393132],[.00187647346,2.07590383214,522.5774180938],[.00086792905,.71001145545,419.4846438752],[.00072062974,.21465724607,536.8045120954],[.00065517248,5.9799588479,316.3918696566],[.00029134542,1.67759379655,103.0927742186],[.00030135335,2.16132003734,949.1756089698],[.00023453271,3.54023522184,735.8765135318],[.00022283743,4.19362594399,1589.0728952838],[.00023947298,.2745803748,7.1135470008],[.00013032614,2.96042965363,1162.4747044078],[970336e-10,1.90669633585,206.1855484372],[.00012749023,2.71550286592,1052.2683831884],[7057931e-11,2.18184839926,1265.5674786264],[6137703e-11,6.26418240033,846.0828347512],[2616976e-11,2.00994012876,1581.959348283]],[[.0127180152,2.64937512894,529.6909650946],[.00061661816,3.00076460387,1059.3819301892],[.00053443713,3.89717383175,522.5774180938],[.00031185171,4.88276958012,536.8045120954],[.00041390269,0,0]]]],Saturn:[[[[.87401354025,0,0],[.11107659762,3.96205090159,213.299095438],[.01414150957,4.58581516874,7.1135470008],[.00398379389,.52112032699,206.1855484372],[.00350769243,3.30329907896,426.598190876],[.00206816305,.24658372002,103.0927742186],[792713e-9,3.84007056878,220.4126424388],[.00023990355,4.66976924553,110.2063212194],[.00016573588,.43719228296,419.4846438752],[.00014906995,5.76903183869,316.3918696566],[.0001582029,.93809155235,632.7837393132],[.00014609559,1.56518472,3.9321532631],[.00013160301,4.44891291899,14.2270940016],[.00015053543,2.71669915667,639.897286314],[.00013005299,5.98119023644,11.0457002639],[.00010725067,3.12939523827,202.2533951741],[5863206e-11,.23656938524,529.6909650946],[5227757e-11,4.20783365759,3.1813937377],[6126317e-11,1.76328667907,277.0349937414],[5019687e-11,3.17787728405,433.7117378768],[459255e-10,.61977744975,199.0720014364],[4005867e-11,2.24479718502,63.7358983034],[2953796e-11,.98280366998,95.9792272178],[387367e-10,3.22283226966,138.5174968707],[2461186e-11,2.03163875071,735.8765135318],[3269484e-11,.77492638211,949.1756089698],[1758145e-11,3.2658010994,522.5774180938],[1640172e-11,5.5050445305,846.0828347512],[1391327e-11,4.02333150505,323.5054166574],[1580648e-11,4.37265307169,309.2783226558],[1123498e-11,2.83726798446,415.5524906121],[1017275e-11,3.71700135395,227.5261894396],[848642e-11,3.1915017083,209.3669421749]],[[213.2990952169,0,0],[.01297370862,1.82834923978,213.299095438],[.00564345393,2.88499717272,7.1135470008],[.00093734369,1.06311793502,426.598190876],[.00107674962,2.27769131009,206.1855484372],[.00040244455,2.04108104671,220.4126424388],[.00019941774,1.2795439047,103.0927742186],[.00010511678,2.7488034213,14.2270940016],[6416106e-11,.38238295041,639.897286314],[4848994e-11,2.43037610229,419.4846438752],[4056892e-11,2.92133209468,110.2063212194],[3768635e-11,3.6496533078,3.9321532631]],[[.0011644133,1.17988132879,7.1135470008],[.00091841837,.0732519584,213.299095438],[.00036661728,0,0],[.00015274496,4.06493179167,206.1855484372]]],[[[.04330678039,3.60284428399,213.299095438],[.00240348302,2.85238489373,426.598190876],[.00084745939,0,0],[.00030863357,3.48441504555,220.4126424388],[.00034116062,.57297307557,206.1855484372],[.0001473407,2.11846596715,639.897286314],[9916667e-11,5.79003188904,419.4846438752],[6993564e-11,4.7360468972,7.1135470008],[4807588e-11,5.43305312061,316.3918696566]],[[.00198927992,4.93901017903,213.299095438],[.00036947916,3.14159265359,0],[.00017966989,.5197943111,426.598190876]]],[[[9.55758135486,0,0],[.52921382865,2.39226219573,213.299095438],[.01873679867,5.2354960466,206.1855484372],[.01464663929,1.64763042902,426.598190876],[.00821891141,5.93520042303,316.3918696566],[.00547506923,5.0153261898,103.0927742186],[.0037168465,2.27114821115,220.4126424388],[.00361778765,3.13904301847,7.1135470008],[.00140617506,5.70406606781,632.7837393132],[.00108974848,3.29313390175,110.2063212194],[.00069006962,5.94099540992,419.4846438752],[.00061053367,.94037691801,639.897286314],[.00048913294,1.55733638681,202.2533951741],[.00034143772,.19519102597,277.0349937414],[.00032401773,5.47084567016,949.1756089698],[.00020936596,.46349251129,735.8765135318],[9796004e-11,5.20477537945,1265.5674786264],[.00011993338,5.98050967385,846.0828347512],[208393e-9,1.52102476129,433.7117378768],[.00015298404,3.0594381494,529.6909650946],[6465823e-11,.17732249942,1052.2683831884],[.00011380257,1.7310542704,522.5774180938],[3419618e-11,4.94550542171,1581.959348283]],[[.0618298134,.2584351148,213.299095438],[.00506577242,.71114625261,206.1855484372],[.00341394029,5.79635741658,426.598190876],[.00188491195,.47215589652,220.4126424388],[.00186261486,3.14159265359,0],[.00143891146,1.40744822888,7.1135470008]],[[.00436902572,4.78671677509,213.299095438]]]],Uranus:[[[[5.48129294297,0,0],[.09260408234,.89106421507,74.7815985673],[.01504247898,3.6271926092,1.4844727083],[.00365981674,1.89962179044,73.297125859],[.00272328168,3.35823706307,149.5631971346],[.00070328461,5.39254450063,63.7358983034],[.00068892678,6.09292483287,76.2660712756],[.00061998615,2.26952066061,2.9689454166],[.00061950719,2.85098872691,11.0457002639],[.0002646877,3.14152083966,71.8126531507],[.00025710476,6.11379840493,454.9093665273],[.0002107885,4.36059339067,148.0787244263],[.00017818647,1.74436930289,36.6485629295],[.00014613507,4.73732166022,3.9321532631],[.00011162509,5.8268179635,224.3447957019],[.0001099791,.48865004018,138.5174968707],[9527478e-11,2.95516862826,35.1640902212],[7545601e-11,5.236265824,109.9456887885],[4220241e-11,3.23328220918,70.8494453042],[40519e-9,2.277550173,151.0476698429],[3354596e-11,1.0654900738,4.4534181249],[2926718e-11,4.62903718891,9.5612275556],[349034e-10,5.48306144511,146.594251718],[3144069e-11,4.75199570434,77.7505439839],[2922333e-11,5.35235361027,85.8272988312],[2272788e-11,4.36600400036,70.3281804424],[2051219e-11,1.51773566586,.1118745846],[2148602e-11,.60745949945,38.1330356378],[1991643e-11,4.92437588682,277.0349937414],[1376226e-11,2.04283539351,65.2203710117],[1666902e-11,3.62744066769,380.12776796],[1284107e-11,3.11347961505,202.2533951741],[1150429e-11,.93343589092,3.1813937377],[1533221e-11,2.58594681212,52.6901980395],[1281604e-11,.54271272721,222.8603229936],[1372139e-11,4.19641530878,111.4301614968],[1221029e-11,.1990065003,108.4612160802],[946181e-11,1.19253165736,127.4717966068],[1150989e-11,4.17898916639,33.6796175129]],[[74.7815986091,0,0],[.00154332863,5.24158770553,74.7815985673],[.00024456474,1.71260334156,1.4844727083],[9258442e-11,.4282973235,11.0457002639],[8265977e-11,1.50218091379,63.7358983034],[915016e-10,1.41213765216,149.5631971346]]],[[[.01346277648,2.61877810547,74.7815985673],[623414e-9,5.08111189648,149.5631971346],[.00061601196,3.14159265359,0],[9963722e-11,1.61603805646,76.2660712756],[992616e-10,.57630380333,73.297125859]],[[.00034101978,.01321929936,74.7815985673]]],[[[19.21264847206,0,0],[.88784984413,5.60377527014,74.7815985673],[.03440836062,.32836099706,73.297125859],[.0205565386,1.7829515933,149.5631971346],[.0064932241,4.52247285911,76.2660712756],[.00602247865,3.86003823674,63.7358983034],[.00496404167,1.40139935333,454.9093665273],[.00338525369,1.58002770318,138.5174968707],[.00243509114,1.57086606044,71.8126531507],[.00190522303,1.99809394714,1.4844727083],[.00161858838,2.79137786799,148.0787244263],[.00143706183,1.38368544947,11.0457002639],[.00093192405,.17437220467,36.6485629295],[.00071424548,4.24509236074,224.3447957019],[.00089806014,3.66105364565,109.9456887885],[.00039009723,1.66971401684,70.8494453042],[.00046677296,1.39976401694,35.1640902212],[.00039025624,3.36234773834,277.0349937414],[.00036755274,3.88649278513,146.594251718],[.00030348723,.70100838798,151.0476698429],[.00029156413,3.180563367,77.7505439839],[.00022637073,.72518687029,529.6909650946],[.00011959076,1.7504339214,984.6003316219],[.00025620756,5.25656086672,380.12776796]],[[.01479896629,3.67205697578,74.7815985673]]]],Neptune:[[[[5.31188633046,0,0],[.0179847553,2.9010127389,38.1330356378],[.01019727652,.48580922867,1.4844727083],[.00124531845,4.83008090676,36.6485629295],[.00042064466,5.41054993053,2.9689454166],[.00037714584,6.09221808686,35.1640902212],[.00033784738,1.24488874087,76.2660712756],[.00016482741,7727998e-11,491.5579294568],[9198584e-11,4.93747051954,39.6175083461],[899425e-10,.27462171806,175.1660598002]],[[38.13303563957,0,0],[.00016604172,4.86323329249,1.4844727083],[.00015744045,2.27887427527,38.1330356378]]],[[[.03088622933,1.44104372644,38.1330356378],[.00027780087,5.91271884599,76.2660712756],[.00027623609,0,0],[.00015355489,2.52123799551,36.6485629295],[.00015448133,3.50877079215,39.6175083461]]],[[[30.07013205828,0,0],[.27062259632,1.32999459377,38.1330356378],[.01691764014,3.25186135653,36.6485629295],[.00807830553,5.18592878704,1.4844727083],[.0053776051,4.52113935896,35.1640902212],[.00495725141,1.5710564165,491.5579294568],[.00274571975,1.84552258866,175.1660598002],[.0001201232,1.92059384991,1021.2488945514],[.00121801746,5.79754470298,76.2660712756],[.00100896068,.3770272493,73.297125859],[.00135134092,3.37220609835,39.6175083461],[7571796e-11,1.07149207335,388.4651552382]]]]};let dt=function(e){var t,n,i,r;const o=2e3+(e-14)/365.24217;return o<-500?32*(t=(o-1820)/100)*t-20:o<500?10583.6-1014.41*(t=o/100)+33.78311*(n=t*t)-5.952053*(i=t*n)-.1798452*(r=n*n)+.022174192*(n*i)+.0090316521*(i*i):o<1600?1574.2-556.01*(t=(o-1e3)/100)+71.23472*(n=t*t)+.319781*(i=t*n)-.8503463*(r=n*n)-.005050998*(n*i)+.0083572073*(i*i):o<1700?120-.9808*(t=o-1600)-.01532*(n=t*t)+(i=t*n)/7129:o<1800?8.83+.1603*(t=o-1700)-.0059285*(n=t*t)+13336e-8*(i=t*n)-(r=n*n)/1174e3:o<1860?13.72-.332447*(t=o-1800)+.0068612*(n=t*t)+.0041116*(i=t*n)-37436e-8*(r=n*n)+121272e-10*(n*i)-1.699e-7*(i*i)+8.75e-10*(i*r):o<1900?7.62+.5737*(t=o-1860)-.251754*(n=t*t)+.01680668*(i=t*n)-.0004473624*(r=n*n)+n*i/233174:o<1920?1.494119*(t=o-1900)-2.79-.0598939*(n=t*t)+.0061966*(i=t*n)-197e-6*(r=n*n):o<1941?21.2+.84493*(t=o-1920)-.0761*(n=t*t)+.0020936*(i=t*n):o<1961?29.07+.407*(t=o-1950)-(n=t*t)/233+(i=t*n)/2547:o<1986?45.45+1.067*(t=o-1975)-(n=t*t)/260-(i=t*n)/718:o<2005?63.86+.3345*(t=o-2e3)-.060374*(n=t*t)+.0017275*(i=t*n)+651814e-9*(r=n*n)+2373599e-11*(n*i):o<2050?62.92+.32217*(t=o-2e3)+.005589*t*t:o<2150?32*(t=(o-1820)/100)*t-20-.5628*(2150-o):32*(t=(o-1820)/100)*t-20};function ht(e){return e+dt(e)/86400}let mt=class e{constructor(t){if(t instanceof e)return this.date=t.date,this.ut=t.ut,void(this.tt=t.tt);const n=864e5;if(t instanceof Date&&Number.isFinite(t.getTime()))return this.date=t,this.ut=(t.getTime()-je.getTime())/n,void(this.tt=ht(this.ut));if(Number.isFinite(t))return this.date=new Date(je.getTime()+t*n),this.ut=t,void(this.tt=ht(this.ut));throw"Argument must be a Date object, an AstroTime object, or a numeric UTC Julian date."}static FromTerrestrialTime(t){let n=new e(t);for(;;){const e=t-n.tt;if(Math.abs(e)<1e-12)return n;n=n.AddDays(e)}}toString(){return this.date.toISOString()}AddDays(t){return new e(this.ut+t)}};function ft(e){return e instanceof mt?e:new mt(e)}function vt(e){var t=e.tt/36525;return(((((-4.34e-8*t-576e-9)*t+.0020034)*t-1831e-7)*t-46.836769)*t+84381.406)/3600}var pt;function _t(e){if(!pt||Math.abs(pt.tt-e.tt)>1e-6){const t=function(e){function t(e){return e%Ke*Xe}const n=e.tt/36525,i=t(1287104.79305+129596581.0481*n),r=t(335779.526232+1739527262.8478*n),o=t(1072260.70369+1602961601.209*n),a=t(450160.398036-6962890.5431*n);let s=Math.sin(a),c=Math.cos(a),u=(-172064161-174666*n)*s+33386*c,l=(92052331+9086*n)*c+15377*s,d=2*(r-o+a);return s=Math.sin(d),c=Math.cos(d),u+=(-13170906-1675*n)*s-13696*c,l+=(5730336-3015*n)*c-4587*s,d=2*(r+a),s=Math.sin(d),c=Math.cos(d),u+=(-2276413-234*n)*s+2796*c,l+=(978459-485*n)*c+1374*s,d=2*a,s=Math.sin(d),c=Math.cos(d),u+=(2074554+207*n)*s-698*c,l+=(470*n-897492)*c-291*s,s=Math.sin(i),c=Math.cos(i),u+=(1475877-3633*n)*s+11817*c,l+=(73871-184*n)*c-1924*s,{dpsi:1e-7*u-135e-6,deps:388e-6+1e-7*l}}(e),n=vt(e),i=n+t.deps/3600;pt={tt:e.tt,dpsi:t.dpsi,deps:t.deps,ee:t.dpsi*Math.cos(n*Ve)/15,mobl:n,tobl:i}}return pt}function gt(e,t){return function(e,t){const n=e*Ve,i=Math.cos(n),r=Math.sin(n);return[t[0],t[1]*i-t[2]*r,t[1]*r+t[2]*i]}(vt(e),t)}function Tt(e,t){const n=e.tt/36525;let i=84381.406,r=((((-9.51e-8*n+132851e-9)*n-.00114045)*n-1.0790069)*n+5038.481507)*n,o=((((3.337e-7*n-467e-9)*n-.00772503)*n+.0512623)*n-.025754)*n+i,a=((((-56e-9*n+170663e-9)*n-.00121197)*n-2.3814292)*n+10.556403)*n;i*=Xe,r*=Xe,o*=Xe,a*=Xe;const s=Math.sin(i),c=Math.cos(i),u=Math.sin(-r),l=Math.cos(-r),d=Math.sin(-o),h=Math.cos(-o),m=Math.sin(a),f=Math.cos(a),v=f*l-u*m*h,p=f*u*c+m*h*l*c-s*m*d,_=f*u*s+m*h*l*s+c*m*d,g=-m*l-u*f*h,T=-m*u*c+f*h*l*c-s*f*d,R=-m*u*s+f*h*l*s+c*f*d,S=u*d,E=-d*l*c-s*h,w=-d*l*s+h*c;if(t===ut.Into2000)return new At([[v,p,_],[g,T,R],[S,E,w]]);if(t===ut.From2000)return new At([[v,g,S],[p,T,E],[_,R,w]]);throw"Invalid precess direction"}let Rt;function St(e){return function(e){if(!Rt||Rt.tt!==e.tt){const t=e.tt/36525;let n=15*_t(e).ee;const i=function(e){let t=(.779057273264+.00273781191135448*e.ut+e.ut%1)%1*360;return t<0&&(t+=360),t}(e);let r=((n+.014506+((((-3.68e-8*t-29956e-9)*t-44e-8)*t+1.3915817)*t+4612.156534)*t)/3600+i)%360/15;r<0&&(r+=24),Rt={tt:e.tt,st:r}}return Rt.st}(ft(e))}class Et{constructor(e,t,n,i){this.x=e,this.y=t,this.z=n,this.t=i}Length(){return Math.hypot(this.x,this.y,this.z)}}class wt{constructor(e,t,n,i,r,o,a){this.x=e,this.y=t,this.z=n,this.vx=i,this.vy=r,this.vz=o,this.t=a}}class yt{constructor(e,t,n){this.lat=it(e),this.lon=it(t),this.dist=it(n)}}class At{constructor(e){this.rot=e}}function xt(e){const t=ft(e),n=function(e){const t=e.tt/36525;function n(e,t){const n=[];let i;for(i=0;i<=t-e;++i)n.push(0);return{min:e,array:n}}function i(e,t,i,r){const o=[];for(let a=0;a<=t-e;++a)o.push(n(i,r));return{min:e,array:o}}function r(e,t,n){const i=e.array[t-e.min];return i.array[n-i.min]}function o(e,t,n,i){const r=e.array[t-e.min];r.array[n-r.min]=i}let a,s,c,u,l,d,h,m,f,v,p,_,g,T,R,S,E,w,y,A,x,C,I,M=i(-6,6,1,4),N=i(-6,6,1,4);function D(e,t){return r(M,e,t)}function O(e,t){return r(N,e,t)}function b(e,t,n){return o(M,e,t,n)}function P(e,t,n){return o(N,e,t,n)}function U(e,t,n,i,r){r(e*n-t*i,t*n+e*i)}function L(e){return Math.sin(qe*e)}h=t*t,f=0,I=0,p=0,_=3422.7;var H=L(.19833+.05611*t),G=L(.27869+.04508*t),F=L(.16827-.36903*t),z=L(.34734-5.37261*t),B=L(.10498-5.37899*t),k=L(.42681-.41855*t);for(w=.84*H+.31*G+14.27*F+7.26*z+.28*B+.24*k,y=2.94*H+.31*G+14.27*F+9.34*z+1.12*B+.83*k,A=-6.4*H-1.89*k,x=.21*H+.31*G+14.27*F-88.7*z-15.3*B+.24*k-1.86*L(.14943-5.37511*t),C=w-A,m=-3332e-9*L(.59734-5.37261*t)-539e-9*L(.35498-5.37899*t)-64e-9*L(.39943-5.37511*t),g=qe*rt(.60643382+1336.85522467*t-313e-8*h)+w/Ye,T=qe*rt(.37489701+1325.55240982*t+2565e-8*h)+y/Ye,R=qe*rt(.99312619+99.99735956*t-44e-8*h)+A/Ye,S=qe*rt(.25909118+1342.2278298*t-892e-8*h)+x/Ye,E=qe*rt(.82736186+1236.85308708*t-397e-8*h)+C/Ye,l=1;l<=4;++l){switch(l){case 1:c=T,s=4,u=1.000002208;break;case 2:c=R,s=3,u=.997504612-.002495388*t;break;case 3:c=S,s=4,u=1.000002708+139.978*m;break;case 4:c=E,s=6,u=1;break;default:throw`Internal error: I = ${l}`}for(b(0,l,1),b(1,l,Math.cos(c)*u),P(0,l,0),P(1,l,Math.sin(c)*u),d=2;d<=s;++d)U(D(d-1,l),O(d-1,l),D(1,l),O(1,l),((e,t)=>(b(d,l,e),P(d,l,t))));for(d=1;d<=s;++d)b(-d,l,D(d,l)),P(-d,l,-O(d,l))}function W(e,t,n,i){for(var r={x:1,y:0},o=[0,e,t,n,i],a=1;a<=4;++a)0!==o[a]&&U(r.x,r.y,D(o[a],a),O(o[a],a),((e,t)=>(r.x=e,r.y=t)));return r}function V(e,t,n,i,r,o,a,s){var c=W(r,o,a,s);f+=e*c.y,I+=t*c.y,p+=n*c.x,_+=i*c.x}function j(e,t,n,i,r){return e*W(t,n,i,r).y}V(13.902,14.06,-.001,.2607,0,0,0,4),V(.403,-4.01,.394,.0023,0,0,0,3),V(2369.912,2373.36,.601,28.2333,0,0,0,2),V(-125.154,-112.79,-.725,-.9781,0,0,0,1),V(1.979,6.98,-.445,.0433,1,0,0,4),V(191.953,192.72,.029,3.0861,1,0,0,2),V(-8.466,-13.51,.455,-.1093,1,0,0,1),V(22639.5,22609.07,.079,186.5398,1,0,0,0),V(18.609,3.59,-.094,.0118,1,0,0,-1),V(-4586.465,-4578.13,-.077,34.3117,1,0,0,-2),V(3.215,5.44,.192,-.0386,1,0,0,-3),V(-38.428,-38.64,.001,.6008,1,0,0,-4),V(-.393,-1.43,-.092,.0086,1,0,0,-6),V(-.289,-1.59,.123,-.0053,0,1,0,4),V(-24.42,-25.1,.04,-.3,0,1,0,2),V(18.023,17.93,.007,.1494,0,1,0,1),V(-668.146,-126.98,-1.302,-.3997,0,1,0,0),V(.56,.32,-.001,-.0037,0,1,0,-1),V(-165.145,-165.06,.054,1.9178,0,1,0,-2),V(-1.877,-6.46,-.416,.0339,0,1,0,-4),V(.213,1.02,-.074,.0054,2,0,0,4),V(14.387,14.78,-.017,.2833,2,0,0,2),V(-.586,-1.2,.054,-.01,2,0,0,1),V(769.016,767.96,.107,10.1657,2,0,0,0),V(1.75,2.01,-.018,.0155,2,0,0,-1),V(-211.656,-152.53,5.679,-.3039,2,0,0,-2),V(1.225,.91,-.03,-.0088,2,0,0,-3),V(-30.773,-34.07,-.308,.3722,2,0,0,-4),V(-.57,-1.4,-.074,.0109,2,0,0,-6),V(-2.921,-11.75,.787,-.0484,1,1,0,2),V(1.267,1.52,-.022,.0164,1,1,0,1),V(-109.673,-115.18,.461,-.949,1,1,0,0),V(-205.962,-182.36,2.056,1.4437,1,1,0,-2),V(.233,.36,.012,-.0025,1,1,0,-3),V(-4.391,-9.66,-.471,.0673,1,1,0,-4),V(.283,1.53,-.111,.006,1,-1,0,4),V(14.577,31.7,-1.54,.2302,1,-1,0,2),V(147.687,138.76,.679,1.1528,1,-1,0,0),V(-1.089,.55,.021,0,1,-1,0,-1),V(28.475,23.59,-.443,-.2257,1,-1,0,-2),V(-.276,-.38,-.006,-.0036,1,-1,0,-3),V(.636,2.27,.146,-.0102,1,-1,0,-4),V(-.189,-1.68,.131,-.0028,0,2,0,2),V(-7.486,-.66,-.037,-.0086,0,2,0,0),V(-8.096,-16.35,-.74,.0918,0,2,0,-2),V(-5.741,-.04,0,-9e-4,0,0,2,2),V(.255,0,0,0,0,0,2,1),V(-411.608,-.2,0,-.0124,0,0,2,0),V(.584,.84,0,.0071,0,0,2,-1),V(-55.173,-52.14,0,-.1052,0,0,2,-2),V(.254,.25,0,-.0017,0,0,2,-3),V(.025,-1.67,0,.0031,0,0,2,-4),V(1.06,2.96,-.166,.0243,3,0,0,2),V(36.124,50.64,-1.3,.6215,3,0,0,0),V(-13.193,-16.4,.258,-.1187,3,0,0,-2),V(-1.187,-.74,.042,.0074,3,0,0,-4),V(-.293,-.31,-.002,.0046,3,0,0,-6),V(-.29,-1.45,.116,-.0051,2,1,0,2),V(-7.649,-10.56,.259,-.1038,2,1,0,0),V(-8.627,-7.59,.078,-.0192,2,1,0,-2),V(-2.74,-2.54,.022,.0324,2,1,0,-4),V(1.181,3.32,-.212,.0213,2,-1,0,2),V(9.703,11.67,-.151,.1268,2,-1,0,0),V(-.352,-.37,.001,-.0028,2,-1,0,-1),V(-2.494,-1.17,-.003,-.0017,2,-1,0,-2),V(.36,.2,-.012,-.0043,2,-1,0,-4),V(-1.167,-1.25,.008,-.0106,1,2,0,0),V(-7.412,-6.12,.117,.0484,1,2,0,-2),V(-.311,-.65,-.032,.0044,1,2,0,-4),V(.757,1.82,-.105,.0112,1,-2,0,2),V(2.58,2.32,.027,.0196,1,-2,0,0),V(2.533,2.4,-.014,-.0212,1,-2,0,-2),V(-.344,-.57,-.025,.0036,0,3,0,-2),V(-.992,-.02,0,0,1,0,2,2),V(-45.099,-.02,0,-.001,1,0,2,0),V(-.179,-9.52,0,-.0833,1,0,2,-2),V(-.301,-.33,0,.0014,1,0,2,-4),V(-6.382,-3.37,0,-.0481,1,0,-2,2),V(39.528,85.13,0,-.7136,1,0,-2,0),V(9.366,.71,0,-.0112,1,0,-2,-2),V(.202,.02,0,0,1,0,-2,-4),V(.415,.1,0,.0013,0,1,2,0),V(-2.152,-2.26,0,-.0066,0,1,2,-2),V(-1.44,-1.3,0,.0014,0,1,-2,2),V(.384,-.04,0,0,0,1,-2,-2),V(1.938,3.6,-.145,.0401,4,0,0,0),V(-.952,-1.58,.052,-.013,4,0,0,-2),V(-.551,-.94,.032,-.0097,3,1,0,0),V(-.482,-.57,.005,-.0045,3,1,0,-2),V(.681,.96,-.026,.0115,3,-1,0,0),V(-.297,-.27,.002,-9e-4,2,2,0,-2),V(.254,.21,-.003,0,2,-2,0,-2),V(-.25,-.22,.004,.0014,1,3,0,-2),V(-3.996,0,0,4e-4,2,0,2,0),V(.557,-.75,0,-.009,2,0,2,-2),V(-.459,-.38,0,-.0053,2,0,-2,2),V(-1.298,.74,0,4e-4,2,0,-2,0),V(.538,1.14,0,-.0141,2,0,-2,-2),V(.263,.02,0,0,1,1,2,0),V(.426,.07,0,-6e-4,1,1,-2,-2),V(-.304,.03,0,3e-4,1,-1,2,0),V(-.372,-.19,0,-.0027,1,-1,-2,2),V(.418,0,0,0,0,0,4,0),V(-.33,-.04,0,0,3,0,2,0),v=0,v+=j(-526.069,0,0,1,-2),v+=j(-3.352,0,0,1,-4),v+=j(44.297,1,0,1,-2),v+=j(-6,1,0,1,-4),v+=j(20.599,-1,0,1,0),v+=j(-30.598,-1,0,1,-2),v+=j(-24.649,-2,0,1,0),v+=j(-2,-2,0,1,-2),v+=j(-22.571,0,1,1,-2),v+=j(10.985,0,-1,1,-2),f+=.82*L(.7736-62.5512*t)+.31*L(.0466-125.1025*t)+.35*L(.5785-25.1042*t)+.66*L(.4591+1335.8075*t)+.64*L(.313-91.568*t)+1.14*L(.148+1331.2898*t)+.21*L(.5918+1056.5859*t)+.44*L(.5784+1322.8595*t)+.24*L(.2275-5.7374*t)+.28*L(.2965+2.6929*t)+.33*L(.3132+6.3368*t),a=S+I/Ye;let q=(1.000002708+139.978*m)*(18518.511+1.189+p)*Math.sin(a)-6.24*Math.sin(3*a)+v;return{geo_eclip_lon:qe*rt((g+f/Ye)/qe),geo_eclip_lat:Math.PI/648e3*q,distance_au:Ye*$e/(.999953253*_)}}(t),i=n.distance_au*Math.cos(n.geo_eclip_lat),r=function(e,t,n){return function(e,t){return[e.rot[0][0]*t[0]+e.rot[1][0]*t[1]+e.rot[2][0]*t[2],e.rot[0][1]*t[0]+e.rot[1][1]*t[1]+e.rot[2][1]*t[2],e.rot[0][2]*t[0]+e.rot[1][2]*t[1]+e.rot[2][2]*t[2]]}(Tt(t,n),e)}(gt(t,[i*Math.cos(n.geo_eclip_lon),i*Math.sin(n.geo_eclip_lon),n.distance_au*Math.sin(n.geo_eclip_lat)]),t,ut.Into2000);return new Et(r[0],r[1],r[2],t)}function Ct(e,t,n){let i=1,r=0;for(let o of e){let e=0;for(let[n,i,r]of o)e+=n*Math.cos(i+t*r);let a=i*e;n&&(a%=qe),r+=a,i*=t}return r}function It(e,t){let n=1,i=0,r=0,o=0;for(let a of e){let e=0,s=0;for(let[n,i,r]of a){let a=i+t*r;e+=n*r*Math.sin(a),o>0&&(s+=n*Math.cos(a))}r+=o*i*s-n*e,i=n,n*=t,++o}return r}const Mt=365250,Nt=0,Dt=1,Ot=2;function bt(e){return new kt(e[0]+4.4036e-7*e[1]-1.90919e-7*e[2],-4.79966e-7*e[0]+.917482137087*e[1]-.397776982902*e[2],.397776982902*e[1]+.917482137087*e[2])}function Pt(e,t,n){const i=n*Math.cos(t);return[i*Math.cos(e),i*Math.sin(e),n*Math.sin(t)]}function Ut(e,t){const n=t.tt/Mt;return bt(Pt(Ct(e[Nt],n,!0),Ct(e[Dt],n,!1),Ct(e[Ot],n,!1))).ToAstroVector(t)}function Lt(e,t,n,i){const r=i/(i+Je),o=Ut(lt[n],t);e.x+=r*o.x,e.y+=r*o.y,e.z+=r*o.z}const Ht=51,Gt=29200,Ft=146,zt=201,Bt=[[-73e4,[-26.118207232108,-14.376168177825,3.384402515299],[.0016339372163656,-.0027861699588508,-.0013585880229445]],[-700800,[41.974905202127,-.448502952929,-12.770351505989],[.00073458569351457,.0022785014891658,.00048619778602049]],[-671600,[14.706930780744,44.269110540027,9.353698474772],[-.00210001479998,.00022295915939915,.00070143443551414]],[-642400,[-29.441003929957,-6.43016153057,6.858481011305],[.00084495803960544,-.0030783914758711,-.0012106305981192]],[-613200,[39.444396946234,-6.557989760571,-13.913760296463],[.0011480029005873,.0022400006880665,.00035168075922288]],[-584e3,[20.2303809507,43.266966657189,7.382966091923],[-.0019754081700585,.00053457141292226,.00075929169129793]],[-554800,[-30.65832536462,2.093818874552,9.880531138071],[61010603013347e-18,-.0031326500935382,-.00099346125151067]],[-525600,[35.737703251673,-12.587706024764,-14.677847247563],[.0015802939375649,.0021347678412429,.00019074436384343]],[-496400,[25.466295188546,41.367478338417,5.216476873382],[-.0018054401046468,.0008328308359951,.00080260156912107]],[-467200,[-29.847174904071,10.636426313081,12.297904180106],[-.00063257063052907,-.0029969577578221,-.00074476074151596]],[-438e3,[30.774692107687,-18.236637015304,-14.945535879896],[.0020113162005465,.0019353827024189,-20937793168297e-19]],[-408800,[30.243153324028,38.656267888503,2.938501750218],[-.0016052508674468,.0011183495337525,.00083333973416824]],[-379600,[-27.288984772533,18.643162147874,14.023633623329],[-.0011856388898191,-.0027170609282181,-.00049015526126399]],[-350400,[24.519605196774,-23.245756064727,-14.626862367368],[.0024322321483154,.0016062008146048,-.00023369181613312]],[-321200,[34.505274805875,35.125338586954,.557361475637],[-.0013824391637782,.0013833397561817,.00084823598806262]],[-292e3,[-23.275363915119,25.818514298769,15.055381588598],[-.0016062295460975,-.0023395961498533,-.00024377362639479]],[-262800,[17.050384798092,-27.180376290126,-13.608963321694],[.0028175521080578,.0011358749093955,-.00049548725258825]],[-233600,[38.093671910285,30.880588383337,-1.843688067413],[-.0011317697153459,.0016128814698472,.00084177586176055]],[-204400,[-18.197852930878,31.932869934309,15.438294826279],[-.0019117272501813,-.0019146495909842,-19657304369835e-18]],[-175200,[8.528924039997,-29.618422200048,-11.805400994258],[.0031034370787005,.0005139363329243,-.00077293066202546]],[-146e3,[40.94685725864,25.904973592021,-4.256336240499],[-.00083652705194051,.0018129497136404,.0008156422827306]],[-116800,[-12.326958895325,36.881883446292,15.217158258711],[-.0021166103705038,-.001481442003599,.00017401209844705]],[-87600,[-.633258375909,-30.018759794709,-9.17193287495],[.0032016994581737,-.00025279858672148,-.0010411088271861]],[-58400,[42.936048423883,20.344685584452,-6.588027007912],[-.00050525450073192,.0019910074335507,.00077440196540269]],[-29200,[-5.975910552974,40.61180995846,14.470131723673],[-.0022184202156107,-.0010562361130164,.00033652250216211]],[0,[-9.875369580774,-27.978926224737,-5.753711824704],[.0030287533248818,-.0011276087003636,-.0012651326732361]],[29200,[43.958831986165,14.214147973292,-8.808306227163],[-.00014717608981871,.0021404187242141,.00071486567806614]],[58400,[.67813676352,43.094461639362,13.243238780721],[-.0022358226110718,-.00063233636090933,.00047664798895648]],[87600,[-18.282602096834,-23.30503958666,-1.766620508028],[.0025567245263557,-.0019902940754171,-.0013943491701082]],[116800,[43.873338744526,7.700705617215,-10.814273666425],[.00023174803055677,.0022402163127924,.00062988756452032]],[146e3,[7.392949027906,44.382678951534,11.629500214854],[-.002193281545383,-.00021751799585364,.00059556516201114]],[175200,[-24.981690229261,-16.204012851426,2.466457544298],[.001819398914958,-.0026765419531201,-.0013848283502247]],[204400,[42.530187039511,.845935508021,-12.554907527683],[.00065059779150669,.0022725657282262,.00051133743202822]],[233600,[13.999526486822,44.462363044894,9.669418486465],[-.0021079296569252,.00017533423831993,.00069128485798076]],[262800,[-29.184024803031,-7.371243995762,6.493275957928],[.00093581363109681,-.0030610357109184,-.0012364201089345]],[292e3,[39.831980671753,-6.078405766765,-13.909815358656],[.0011117769689167,.0022362097830152,.00036230548231153]],[321200,[20.294955108476,43.417190420251,7.450091985932],[-.0019742157451535,.00053102050468554,.00075938408813008]],[350400,[-30.66999230216,2.318743558955,9.973480913858],[45605107450676e-18,-.0031308219926928,-.00099066533301924]],[379600,[35.626122155983,-12.897647509224,-14.777586508444],[.0016015684949743,.0021171931182284,.00018002516202204]],[408800,[26.133186148561,41.232139187599,5.00640132622],[-.0017857704419579,.00086046232702817,.00080614690298954]],[438e3,[-29.57674022923,11.863535943587,12.631323039872],[-.00072292830060955,-.0029587820140709,-.000708242964503]],[467200,[29.910805787391,-19.159019294,-15.013363865194],[.0020871080437997,.0018848372554514,-38528655083926e-18]],[496400,[31.375957451819,38.050372720763,2.433138343754],[-.0015546055556611,.0011699815465629,.00083565439266001]],[525600,[-26.360071336928,20.662505904952,14.414696258958],[-.0013142373118349,-.0026236647854842,-.00042542017598193]],[554800,[22.599441488648,-24.508879898306,-14.484045731468],[.0025454108304806,.0014917058755191,-.00030243665086079]],[584e3,[35.877864013014,33.894226366071,-.224524636277],[-.0012941245730845,.0014560427668319,.00084762160640137]],[613200,[-21.538149762417,28.204068269761,15.321973799534],[-.001731211740901,-.0021939631314577,-.0001631691327518]],[642400,[13.971521374415,-28.339941764789,-13.083792871886],[.0029334630526035,.00091860931752944,-.00059939422488627]],[671600,[39.526942044143,28.93989736011,-2.872799527539],[-.0010068481658095,.001702113288809,.00083578230511981]],[700800,[-15.576200701394,34.399412961275,15.466033737854],[-.0020098814612884,-.0017191109825989,70414782780416e-18]],[73e4,[4.24325283709,-30.118201690825,-10.707441231349],[.0031725847067411,.0001609846120227,-.00090672150593868]]];let kt=class e{constructor(e,t,n){this.x=e,this.y=t,this.z=n}clone(){return new e(this.x,this.y,this.z)}ToAstroVector(e){return new Et(this.x,this.y,this.z,e)}static zero(){return new e(0,0,0)}quadrature(){return this.x*this.x+this.y*this.y+this.z*this.z}add(t){return new e(this.x+t.x,this.y+t.y,this.z+t.z)}sub(t){return new e(this.x-t.x,this.y-t.y,this.z-t.z)}incr(e){this.x+=e.x,this.y+=e.y,this.z+=e.z}decr(e){this.x-=e.x,this.y-=e.y,this.z-=e.z}mul(t){return new e(t*this.x,t*this.y,t*this.z)}div(t){return new e(this.x/t,this.y/t,this.z/t)}mean(t){return new e((this.x+t.x)/2,(this.y+t.y)/2,(this.z+t.z)/2)}neg(){return new e(-this.x,-this.y,-this.z)}},Wt=class e{constructor(e,t,n){this.tt=e,this.r=t,this.v=n}clone(){return new e(this.tt,this.r,this.v)}sub(t){return new e(this.tt,this.r.sub(t.r),this.v.sub(t.v))}};function Vt(e,t,n,i){const r=i/(i+Je),o=function(e,t){const n=t/Mt,i=Ct(e[Nt],n,!0),r=Ct(e[Dt],n,!1),o=Ct(e[Ot],n,!1),a=It(e[Nt],n),s=It(e[Dt],n),c=It(e[Ot],n),u=Math.cos(i),l=Math.sin(i),d=Math.cos(r),h=Math.sin(r),m=+c*d*u-o*h*u*s-o*d*l*a,f=+c*d*l-o*h*l*s+o*d*u*a,v=+c*h+o*d*s,p=Pt(i,r,o),_=[m/Mt,f/Mt,v/Mt],g=bt(p),T=bt(_);return new Wt(t,g,T)}(lt[n],t);return e.r.incr(o.r.mul(r)),e.v.incr(o.v.mul(r)),o}function jt(e,t,n){const i=n.sub(e),r=i.quadrature();return i.mul(t/(r*Math.sqrt(r)))}class qt{constructor(e){let t=new Wt(e,new kt(0,0,0),new kt(0,0,0));this.Jupiter=Vt(t,e,ot.Jupiter,Qe),this.Saturn=Vt(t,e,ot.Saturn,et),this.Uranus=Vt(t,e,ot.Uranus,tt),this.Neptune=Vt(t,e,ot.Neptune,nt),this.Jupiter.r.decr(t.r),this.Jupiter.v.decr(t.v),this.Saturn.r.decr(t.r),this.Saturn.v.decr(t.v),this.Uranus.r.decr(t.r),this.Uranus.v.decr(t.v),this.Neptune.r.decr(t.r),this.Neptune.v.decr(t.v),this.Sun=new Wt(e,t.r.mul(-1),t.v.mul(-1))}Acceleration(e){let t=jt(e,Je,this.Sun.r);return t.incr(jt(e,Qe,this.Jupiter.r)),t.incr(jt(e,et,this.Saturn.r)),t.incr(jt(e,tt,this.Uranus.r)),t.incr(jt(e,nt,this.Neptune.r)),t}}class Yt{constructor(e,t,n,i){this.tt=e,this.r=t,this.v=n,this.a=i}clone(){return new Yt(this.tt,this.r.clone(),this.v.clone(),this.a.clone())}}class Xt{constructor(e,t){this.bary=e,this.grav=t}}function Kt(e,t,n,i){return new kt(t.x+e*(n.x+e*i.x/2),t.y+e*(n.y+e*i.y/2),t.z+e*(n.z+e*i.z/2))}function $t(e,t,n){return new kt(t.x+e*n.x,t.y+e*n.y,t.z+e*n.z)}function Zt(e,t){const n=e-t.tt,i=new qt(e),r=Kt(n,t.r,t.v,t.a),o=i.Acceleration(r).mean(t.a),a=Kt(n,t.r,t.v,o),s=t.v.add(o.mul(n)),c=i.Acceleration(a),u=new Yt(e,a,s,c);return new Xt(i,u)}const Jt=[];function Qt(e,t){const n=Math.floor(e);return n<0?0:n>=t?t-1:n}function en(e){const t=function(e){let[t,[n,i,r],[o,a,s]]=e;return new Wt(t,new kt(n,i,r),new kt(o,a,s))}(e),n=new qt(t.tt),i=t.r.add(n.Sun.r),r=t.v.add(n.Sun.v),o=n.Acceleration(i),a=new Yt(t.tt,i,r,o);return new Xt(n,a)}function tn(e,t,n){let i=en(e);const r=Math.ceil((t-i.grav.tt)/n);for(let e=0;e<r;++e)i=Zt(e+1===r?t:i.grav.tt+n,i.grav);return i}function nn(e,t){let n,i,r;const o=function(e,t){const n=Bt[0][0];if(t<n||t>Bt[Ht-1][0])return null;const i=Qt((t-n)/Gt,Ht-1);if(!e[i]){const t=e[i]=[];t[0]=en(Bt[i]).grav,t[zt-1]=en(Bt[i+1]).grav;let n,o=t[0].tt;for(n=1;n<zt-1;++n)t[n]=Zt(o+=Ft,t[n-1]).grav;o=t[zt-1].tt;var r=[];for(r[zt-1]=t[zt-1],n=zt-2;n>0;--n)r[n]=Zt(o-=Ft,r[n+1]).grav;for(n=zt-2;n>0;--n){const e=n/(zt-1);t[n].r=t[n].r.mul(1-e).add(r[n].r.mul(e)),t[n].v=t[n].v.mul(1-e).add(r[n].v.mul(e)),t[n].a=t[n].a.mul(1-e).add(r[n].a.mul(e))}}return e[i]}(Jt,e.tt);if(o){const t=Qt((e.tt-o[0].tt)/Ft,zt-1),r=o[t],a=o[t+1],s=r.a.mean(a.a),c=Kt(e.tt-r.tt,r.r,r.v,s),u=$t(e.tt-r.tt,r.v,s),l=Kt(e.tt-a.tt,a.r,a.v,s),d=$t(e.tt-a.tt,a.v,s),h=(e.tt-r.tt)/Ft;n=c.mul(1-h).add(l.mul(h)),i=u.mul(1-h).add(d.mul(h))}else{let t;t=e.tt<Bt[0][0]?tn(Bt[0],e.tt,-Ft):tn(Bt[Ht-1],e.tt,+Ft),n=t.grav.r,i=t.grav.v,r=t.bary}return r||(r=new qt(e.tt)),n=n.sub(r.Sun.r),i=i.sub(r.Sun.v),new wt(n.x,n.y,n.z,i.x,i.y,i.z,e)}function rn(e,t){var n=ft(t);if(e in lt)return Ut(lt[e],n);if(e===ot.Pluto){const e=nn(n);return new Et(e.x,e.y,e.z,n)}if(e===ot.Sun)return new Et(0,0,0,n);if(e===ot.Moon){var i=Ut(lt.Earth,n),r=xt(n);return new Et(i.x+r.x,i.y+r.y,i.z+r.z,n)}if(e===ot.EMB){const e=Ut(lt.Earth,n),t=xt(n),i=1+Ze;return new Et(e.x+t.x/i,e.y+t.y/i,e.z+t.z/i,n)}if(e===ot.SSB)return function(e){const t=new Et(0,0,0,e);return Lt(t,e,ot.Jupiter,Qe),Lt(t,e,ot.Saturn,et),Lt(t,e,ot.Uranus,tt),Lt(t,e,ot.Neptune,nt),t}(n);const o=ct(e);if(o){return function(e,t){t=ft(t);const n=e.lat*Ve,i=e.lon*Ve,r=e.dist*Math.cos(n);return new Et(r*Math.cos(i),r*Math.sin(i),e.dist*Math.sin(n),t)}(new yt(o.dec,15*o.ra,o.dist),n)}throw`HelioVector: Unknown body "${e}"`}class on{constructor(e,t,n,i){this.observerBody=e,this.targetBody=t,this.aberration=n,this.observerPos=i}Position(e){this.aberration&&(this.observerPos=rn(this.observerBody,e));const t=rn(this.targetBody,e);return new Et(t.x-this.observerPos.x,t.y-this.observerPos.y,t.z-this.observerPos.z,e)}}function an(e,t,n,i){const r=ft(e);if(ct(n)){const e=rn(n,r),i=rn(t,r);return new Et(e.x-i.x,e.y-i.y,e.z-i.z,r)}let o;o=rn(t,r);const a=new on(t,n,i,o);return function(e,t){let n=t,i=0;for(let r=0;r<10;++r){const r=e(n),o=r.Length()/We;if(o>1)throw"Object is too distant for light-travel solver.";const a=t.AddDays(-o);if(i=Math.abs(a.tt-n.tt),i<1e-9)return r;n=a}throw`Light-travel time solver did not converge: dt = ${i}`}((e=>a.Position(e)),r)}var sn,cn,un;function ln(e,t){return new At([[t.rot[0][0]*e.rot[0][0]+t.rot[1][0]*e.rot[0][1]+t.rot[2][0]*e.rot[0][2],t.rot[0][1]*e.rot[0][0]+t.rot[1][1]*e.rot[0][1]+t.rot[2][1]*e.rot[0][2],t.rot[0][2]*e.rot[0][0]+t.rot[1][2]*e.rot[0][1]+t.rot[2][2]*e.rot[0][2]],[t.rot[0][0]*e.rot[1][0]+t.rot[1][0]*e.rot[1][1]+t.rot[2][0]*e.rot[1][2],t.rot[0][1]*e.rot[1][0]+t.rot[1][1]*e.rot[1][1]+t.rot[2][1]*e.rot[1][2],t.rot[0][2]*e.rot[1][0]+t.rot[1][2]*e.rot[1][1]+t.rot[2][2]*e.rot[1][2]],[t.rot[0][0]*e.rot[2][0]+t.rot[1][0]*e.rot[2][1]+t.rot[2][0]*e.rot[2][2],t.rot[0][1]*e.rot[2][0]+t.rot[1][1]*e.rot[2][1]+t.rot[2][1]*e.rot[2][2],t.rot[0][2]*e.rot[2][0]+t.rot[1][2]*e.rot[2][1]+t.rot[2][2]*e.rot[2][2]]])}function dn(e){const t=Tt(e=ft(e),ut.From2000),n=function(e,t){const n=_t(e),i=n.mobl*Ve,r=n.tobl*Ve,o=n.dpsi*Xe,a=Math.cos(i),s=Math.sin(i),c=Math.cos(r),u=Math.sin(r),l=Math.cos(o),d=Math.sin(o),h=l,m=-d*a,f=-d*s,v=d*c,p=l*a*c+s*u,_=l*s*c-a*u,g=d*u,T=l*a*u-s*c,R=l*s*u+a*c;if(t===ut.From2000)return new At([[h,v,g],[m,p,T],[f,_,R]]);if(t===ut.Into2000)return new At([[h,m,f],[v,p,_],[g,T,R]]);throw"Invalid precess direction"}(e,ut.From2000);return ln(t,n)}function hn(e){return e instanceof mt?e:new mt(e instanceof Date?e:new Date(e))}function mn(e,n=new t){const i=hn(e),r=dn(i),o=function(e){const t=Math.cos(e),n=Math.sin(e);return new At([[t,-n,0],[n,t,0],[0,0,1]])}(St(i)*(-Math.PI/12)),{rot:a}=ln(r,o);return n.set(a[0][0],a[0][1],a[0][2],0,a[1][0],a[1][1],a[1][2],0,a[2][0],a[2][1],a[2][2],0,0,0,0,1)}function fn(e,t,n){const{x:i,y:r,z:o}=function(e,t,n){const i=ft(t);switch(e){case ot.Earth:return new Et(0,0,0,i);case ot.Moon:return xt(i);default:const t=an(i,ot.Earth,e,n);return t.t=i,t}}(e,t,!1);return n.set(i,r,o).normalize()}function vn(e){return Math.sqrt(Math.max(e,0))}function pn(e,t,n){const{topRadius:i}=e;return function(e){return Math.max(e,0)}(-t*n+vn(t**2*(n**2-1)+i**2))}function _n(e,t){return.5/t+e*(1-1/t)}!function(e){e[e.Pericenter=0]="Pericenter",e[e.Apocenter=1]="Apocenter"}(sn||(sn={})),function(e){e.Penumbral="penumbral",e.Partial="partial",e.Annular="annular",e.Total="total"}(cn||(cn={})),function(e){e[e.Invalid=0]="Invalid",e[e.Ascending=1]="Ascending",e[e.Descending=-1]="Descending"}(un||(un={}));var gn="Invariant failed";const Tn=new e,Rn=new e,Sn=new e;function En(e,t,n){const i=4*t;return n.set(e[i],e[i+1],e[i+2])}function wn(e,t,n){const{data:i,width:r,height:o}=e.image;!function(e,t){if(!e)throw new Error(gn)}(i instanceof Float32Array);const a=me(t.x,0,1)*(r-1),s=me(t.y,0,1)*(o-1),c=Math.floor(a),u=Math.floor(s),l=a-c,d=s-u,h=c%r,m=(h+1)%r,f=u%o,v=(f+1)%o,p=En(i,f*r+h,Tn),_=En(i,f*r+m,Rn),g=p.lerp(_,l),T=En(i,v*r+h,Rn),R=En(i,v*r+m,Sn),S=T.lerp(R,l);return n.copy(g.lerp(S,d))}const yn=new e,An=new e,xn=new f;function Cn(e,t,n,i=new g,{ellipsoid:r=$.WGS84,correctAltitude:o=!0,photometric:a=!0}={},s=Ie.DEFAULT){const c=yn.copy(t);if(o){const e=r.projectOnSurface(t,An);null!=e&&c.sub(r.getOsculatingSphereCenter(e,s.bottomRadius,An))}const u=An;let l=c.length(),d=c.dot(n);const{topRadius:h}=s,m=-d-Math.sqrt(d**2-l**2+h**2);if(m>0&&(l=h,d+=m),l>h)u.set(1,1,1);else{const t=d/l;if(function(e,t,n){const{bottomRadius:i}=e;return n<0&&t**2*(n**2-1)+i**2>=0}(s,l,t))u.setScalar(0);else{const n=function(e,t,n,i){const{topRadius:r,bottomRadius:o}=e,a=Math.sqrt(r**2-o**2),s=vn(t**2-o**2),c=r-t,u=(pn(e,t,n)-c)/(s+a-c),l=s/a;return i.set(_n(u,Me),_n(l,Ne))}(s,l,t,xn);wn(e,n,u)}}const f=u.multiply(s.solarIrradiance);return a&&f.multiply(s.sunRadianceToRelativeLuminance),i.setFromVector3(f)}function In(){return function(e){var t=[];if(0===e.length)return"";if("string"!=typeof e[0])throw new TypeError("Url must be a string. Received "+e[0]);if(e[0].match(/^[^/:]+:\/*$/)&&e.length>1){var n=e.shift();e[0]=n+e[0]}e[0].match(/^file:\/\/\//)?e[0]=e[0].replace(/^([^/:]+):\/*/,"$1:///"):e[0]=e[0].replace(/^([^/:]+):\/*/,"$1://");for(var i=0;i<e.length;i++){var r=e[i];if("string"!=typeof r)throw new TypeError("Url must be a string. Received "+r);""!==r&&(i>0&&(r=r.replace(/^[\/]+/,"")),r=i<e.length-1?r.replace(/[\/]+$/,""):r.replace(/[\/]+$/,"/"),t.push(r))}var o=t.join("/"),a=(o=o.replace(/\/(\?|&|#[^!])/g,"$1")).split("?");return a.shift()+(a.length>0?"?":"")+a.join("&")}("object"==typeof arguments[0]?arguments[0]:[].slice.call(arguments))}class Mn extends i{constructor(){super(...arguments),Ae(this,"useHalfFloat",!1)}load(e,t,n,i){const r={},o=(o,{Loader:a,suffix:s=""})=>{const c=new a(this.manager);c.setRequestHeader(this.requestHeader),c.setPath(this.path),c.setWithCredentials(this.withCredentials),c.load(In(e,`${o}${s}.bin`),(e=>{this.useHalfFloat&&(e.internalFormat="RGBA16F"),r[`${o}Texture`]=e,null!=r.irradianceTexture&&null!=r.scatteringTexture&&null!=r.transmittanceTexture&&t(r)}),n,i)};o("irradiance",{Loader:he(ae,{width:64,height:16})}),o("scattering",{Loader:de(ae,{width:256,height:128,depth:32}),suffix:this.useHalfFloat?"":"_float"}),o("transmittance",{Loader:he(ae,{width:Me,height:Ne})})}}const Nn=1/Math.sqrt(Math.PI),Dn=Math.sqrt(3)/(2*Math.sqrt(Math.PI)),On=new e,bn=new e,Pn=new f,Un=new t,Ln={ellipsoid:$.WGS84,correctAltitude:!0,photometric:!0};class Hn extends p{constructor(n,i=Ie.DEFAULT){super(),Ae(this,"irradianceTexture"),Ae(this,"ellipsoid"),Ae(this,"ellipsoidCenter",new e),Ae(this,"ellipsoidMatrix",new t),Ae(this,"correctAltitude"),Ae(this,"photometric"),Ae(this,"sunDirection"),this.atmosphere=i;const{irradianceTexture:r=null,ellipsoid:o,correctAltitude:a,photometric:s,sunDirection:c}={...Ln,...n};this.irradianceTexture=r,this.ellipsoid=o,this.correctAltitude=a,this.photometric=s,this.sunDirection=(null==c?void 0:c.clone())??new e}update(){if(null==this.irradianceTexture)return;const e=Un.copy(this.ellipsoidMatrix).invert(),t=this.getWorldPosition(On).applyMatrix4(e).sub(this.ellipsoidCenter);if(this.correctAltitude){const e=this.ellipsoid.projectOnSurface(t,bn);null!=e&&t.sub(be(e,this.atmosphere.bottomRadius,this.ellipsoid,bn))}const n=t.length(),i=t.dot(this.sunDirection)/n,r=function({topRadius:e,bottomRadius:t},n,i,r){const o=(n-t)/(e-t),a=.5*i+.5;return r.set(_n(a,64),_n(o,16))}(this.atmosphere,n,i,Pn),o=wn(this.irradianceTexture,r,bn);this.photometric&&o.multiply(this.atmosphere.skyRadianceToRelativeLuminance);const a=this.ellipsoid.getSurfaceNormal(t).applyMatrix4(this.ellipsoidMatrix),s=this.sh.coefficients;s[0].copy(o).multiplyScalar(Nn),s[1].copy(o).multiplyScalar(Dn*a.y),s[2].copy(o).multiplyScalar(Dn*a.z),s[3].copy(o).multiplyScalar(Dn*a.x)}}const Gn={...Be,sun:!0,moon:!0,moonAngularRadius:.0045,lunarRadianceScale:1};class Fn extends ke{constructor(n){const{sun:i,moon:r,moonDirection:o,moonAngularRadius:a,lunarRadianceScale:s,groundAlbedo:c,...u}={...Gn,...n};super({name:"SkyMaterial",glslVersion:_,vertexShader:ge('precision highp float;\nprecision highp sampler3D;\n\n#include "parameters"\n\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 inverseViewMatrix;\nuniform vec3 cameraPosition;\nuniform vec3 ellipsoidCenter;\nuniform mat4 inverseEllipsoidMatrix;\nuniform vec3 altitudeCorrection;\n\nlayout(location = 0) in vec3 position;\n\nout vec2 vUv;\nout vec3 vCameraPosition;\nout vec3 vRayDirection;\nout vec3 vEllipsoidCenter;\n\nvoid getCameraRay(out vec3 origin, out vec3 direction) {\n  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column\n\n  if (isPerspective) {\n    // Calculate the camera ray for a perspective camera.\n    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);\n    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);\n    origin = cameraPosition;\n    direction = worldDirection.xyz;\n  } else {\n    // Unprojected points to calculate direction.\n    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);\n    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);\n    nearPoint /= nearPoint.w;\n    farPoint /= farPoint.w;\n\n    // Calculate world values\n    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);\n    vec4 worldOrigin = inverseViewMatrix * nearPoint;\n\n    // Outputs\n    direction = worldDirection.xyz;\n    origin = worldOrigin.xyz;\n  }\n}\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n\n  vec3 direction, origin;\n  getCameraRay(origin, direction);\n\n  mat3 rotation = mat3(inverseEllipsoidMatrix);\n  vCameraPosition = rotation * origin.xyz * METER_TO_LENGTH_UNIT;\n  vRayDirection = rotation * direction.xyz;\n  vEllipsoidCenter = (ellipsoidCenter + altitudeCorrection) * METER_TO_LENGTH_UNIT;\n\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n',{parameters:we}),fragmentShader:ge('precision highp float;\nprecision highp sampler3D;\n\n#define RECIPROCAL_PI (0.3183098861837907)\n\n#include "core/raySphereIntersection"\n#include "parameters"\n#include "functions"\n#include "sky"\n\nuniform vec3 sunDirection;\nuniform vec3 moonDirection;\nuniform float moonAngularRadius;\nuniform float lunarRadianceScale;\nuniform vec3 groundAlbedo;\n\n#ifdef HAS_SHADOW_LENGTH\nuniform sampler2D shadowLengthBuffer;\n#endif // HAS_SHADOW_LENGTH\n\nin vec2 vUv;\nin vec3 vCameraPosition;\nin vec3 vRayDirection;\nin vec3 vEllipsoidCenter;\n\nlayout(location = 0) out vec4 outputColor;\n\n#include <mrt_layout>\n\nbool rayIntersectsGround(const vec3 cameraPosition, const vec3 rayDirection) {\n  float r = length(cameraPosition);\n  float mu = dot(cameraPosition, rayDirection) / r;\n  return mu < 0.0 && r * r * (mu * mu - 1.0) + u_bottom_radius * u_bottom_radius >= 0.0;\n}\n\nvoid main() {\n  float shadowLength = 0.0;\n  #ifdef HAS_SHADOW_LENGTH\n  shadowLength = texture(shadowLengthBuffer, vUv).r;\n  #endif // HAS_SHADOW_LENGTH\n\n  vec3 cameraPosition = vCameraPosition - vEllipsoidCenter;\n  vec3 rayDirection = normalize(vRayDirection);\n\n  #ifdef GROUND_ALBEDO\n\n  bool intersectsGround = rayIntersectsGround(cameraPosition, rayDirection);\n  if (intersectsGround) {\n    float distanceToGround = raySphereFirstIntersection(\n      cameraPosition,\n      rayDirection,\n      u_bottom_radius\n    );\n    vec3 groundPosition = rayDirection * distanceToGround + cameraPosition;\n    vec3 surfaceNormal = normalize(groundPosition);\n    vec3 skyIrradiance;\n    vec3 sunIrradiance = GetSunAndSkyIrradiance(\n      cameraPosition,\n      surfaceNormal,\n      sunDirection,\n      skyIrradiance\n    );\n    vec3 transmittance;\n    vec3 inscatter = GetSkyRadianceToPoint(\n      cameraPosition,\n      u_bottom_radius * surfaceNormal,\n      shadowLength,\n      sunDirection,\n      transmittance\n    );\n    vec3 radiance = groundAlbedo * RECIPROCAL_PI * (sunIrradiance + skyIrradiance);\n    outputColor.rgb = radiance * transmittance + inscatter;\n  } else {\n    outputColor.rgb = getSkyRadiance(\n      cameraPosition,\n      rayDirection,\n      shadowLength,\n      sunDirection,\n      moonDirection,\n      moonAngularRadius,\n      lunarRadianceScale\n    );\n  }\n\n  #else // GROUND_ALBEDO\n\n  outputColor.rgb = getSkyRadiance(\n    cameraPosition,\n    rayDirection,\n    shadowLength,\n    sunDirection,\n    moonDirection,\n    moonAngularRadius,\n    lunarRadianceScale\n  );\n\n  #endif // GROUND_ALBEDO\n\n  outputColor.a = 1.0;\n\n  #include <mrt_output>\n}\n',{core:{raySphereIntersection:Se},parameters:we,functions:Ee,sky:Pe}),...u,uniforms:{inverseProjectionMatrix:new m(new t),inverseViewMatrix:new m(new t),moonDirection:new m((null==o?void 0:o.clone())??new e),moonAngularRadius:new m(a),lunarRadianceScale:new m(s),groundAlbedo:new m((null==c?void 0:c.clone())??new g(0)),shadowLengthBuffer:new m(null),...u.uniforms},defines:{PERSPECTIVE_CAMERA:"1"},depthTest:!0}),this.sun=i,this.moon=r}onBeforeCompile(e,t){super.onBeforeCompile(e,t);const n=this.groundAlbedo,i=0!==n.r||0!==n.g||0!==n.b;null!=this.defines.GROUND_ALBEDO!==i&&(i?this.defines.GROUND_ALBEDO="1":delete this.defines.GROUND_ALBEDO,this.needsUpdate=!0)}onBeforeRender(e,t,n,i,r,o){super.onBeforeRender(e,t,n,i,r,o);const a=this.uniforms;a.inverseProjectionMatrix.value.copy(n.projectionMatrixInverse),a.inverseViewMatrix.value.copy(n.matrixWorld);const s=!0===n.isPerspectiveCamera;null!=this.defines.PERSPECTIVE_CAMERA!==s&&(s?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}get sun(){return null!=this.defines.SUN}set sun(e){e!==this.sun&&(e?this.defines.SUN="1":delete this.defines.SUN,this.needsUpdate=!0)}get moon(){return null!=this.defines.MOON}set moon(e){e!==this.moon&&(e?this.defines.MOON="1":delete this.defines.MOON,this.needsUpdate=!0)}get moonDirection(){return this.uniforms.moonDirection.value}get moonAngularRadius(){return this.uniforms.moonAngularRadius.value}set moonAngularRadius(e){this.uniforms.moonAngularRadius.value=e}get lunarRadianceScale(){return this.uniforms.lunarRadianceScale.value}set lunarRadianceScale(e){this.uniforms.lunarRadianceScale.value=e}get groundAlbedo(){return this.uniforms.groundAlbedo.value}setUniform(e,t){t instanceof m?this.uniforms[e]=t:this.uniforms[e].value=t}set shadowLength(e){null!=e?(this.defines.HAS_SHADOW_LENGTH="1",this.setUniform("shadowLengthBuffer",e.map)):(delete this.defines.HAS_SHADOW_LENGTH,this.uniforms.shadowLengthBuffer.value=null),this.needsUpdate=!0}}class zn extends T{constructor(t){super();const n=new Int16Array(t),i=new Uint8Array(t),r=new R(n,5),o=new R(i,10);this.setAttribute("position",new S(r,3,0,!0)),this.setAttribute("magnitude",new S(o,1,6,!0)),this.setAttribute("color",new S(o,3,7,!0)),this.boundingSphere=new E(new e,1)}}const Bn={...Be,pointSize:1,radianceScale:1,background:!0};class kn extends ke{constructor(e){const{pointSize:n,radianceScale:i,background:r,...o}={...Bn,...e};super({name:"StarsMaterial",glslVersion:_,vertexShader:ge('precision highp float;\nprecision highp sampler3D;\n\n#include "parameters"\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 matrixWorld;\nuniform vec3 cameraPosition;\nuniform float cameraFar;\nuniform vec3 ellipsoidCenter;\nuniform mat4 inverseEllipsoidMatrix;\nuniform vec3 altitudeCorrection;\nuniform float pointSize;\nuniform vec2 magnitudeRange;\nuniform float radianceScale;\n\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in float magnitude;\nlayout(location = 2) in vec3 color;\n\nout vec3 vCameraPosition;\nout vec3 vRayDirection;\nout vec3 vEllipsoidCenter;\nout vec3 vColor;\n\nvoid main() {\n  // Magnitude is stored between 0 to 1 within the given range.\n  float m = mix(magnitudeRange.x, magnitudeRange.y, magnitude);\n  vec3 v = pow(vec3(10.0), -vec3(magnitudeRange, m) / 2.5);\n  vColor = vec3(radianceScale * color);\n  vColor *= saturate((v.z - v.y) / (v.x - v.y));\n\n  #ifdef BACKGROUND\n  vec3 worldDirection = normalize(matrixWorld * vec4(position, 1.0)).xyz;\n  mat3 rotation = mat3(inverseEllipsoidMatrix);\n  vCameraPosition = rotation * cameraPosition * METER_TO_LENGTH_UNIT;\n  vRayDirection = rotation * worldDirection;\n  vEllipsoidCenter =\n    (ellipsoidCenter + altitudeCorrection) * METER_TO_LENGTH_UNIT;\n  gl_Position =\n    projectionMatrix * viewMatrix * vec4(cameraPosition + worldDirection * cameraFar, 1.0);\n  #else // BACKGROUND\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  #endif // BACKGROUND\n\n  gl_PointSize = pointSize;\n}\n',{parameters:we}),fragmentShader:ge('precision highp float;\nprecision highp sampler3D;\n\n#include "parameters"\n#include "functions"\n\nuniform vec3 sunDirection;\n\nin vec3 vCameraPosition;\nin vec3 vRayDirection;\nin vec3 vEllipsoidCenter;\n\nlayout(location = 0) out vec4 outputColor;\n\n#include <mrt_layout>\n\nin vec3 vColor;\n\nvoid main() {\n  #if !defined(PERSPECTIVE_CAMERA)\n  outputColor = vec4(0.0);\n  discard; // Rendering celestial objects without perspective doesn\'t make sense.\n  #endif // !defined(PERSPECTIVE_CAMERA)\n\n  #ifdef BACKGROUND\n  vec3 cameraPosition = vCameraPosition - vEllipsoidCenter;\n  vec3 rayDirection = normalize(vRayDirection);\n  float r = length(cameraPosition);\n  float mu = dot(cameraPosition, rayDirection) / r;\n\n  if (RayIntersectsGround(r, mu)) {\n    discard;\n  }\n\n  vec3 transmittance;\n  vec3 radiance = GetSkyRadiance(\n    vCameraPosition - vEllipsoidCenter,\n    normalize(vRayDirection),\n    0.0,\n    sunDirection,\n    transmittance\n  );\n  radiance += transmittance * vColor;\n  outputColor = vec4(radiance, 1.0);\n  #else // BACKGROUND\n  outputColor = vec4(vColor, 1.0);\n  #endif // BACKGROUND\n\n  #include <mrt_output>\n}\n',{parameters:we,functions:Ee}),...o,uniforms:{projectionMatrix:new m(new t),modelViewMatrix:new m(new t),viewMatrix:new m(new t),matrixWorld:new m(new t),cameraFar:new m(0),pointSize:new m(0),magnitudeRange:new m(new f(-2,8)),radianceScale:new m(i),...o.uniforms},defines:{PERSPECTIVE_CAMERA:"1"}}),Ae(this,"pointSize"),this.pointSize=n,this.background=r}onBeforeRender(e,t,n,i,r,o){super.onBeforeRender(e,t,n,i,r,o);const a=this.uniforms;a.projectionMatrix.value.copy(n.projectionMatrix),a.modelViewMatrix.value.copy(n.modelViewMatrix),a.viewMatrix.value.copy(n.matrixWorldInverse),a.matrixWorld.value.copy(r.matrixWorld),a.cameraFar.value=n.far,a.pointSize.value=this.pointSize*e.getPixelRatio();const s=!0===n.isPerspectiveCamera;null!=this.defines.PERSPECTIVE_CAMERA!==s&&(s?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}get magnitudeRange(){return this.uniforms.magnitudeRange.value}get radianceScale(){return this.uniforms.radianceScale.value}set radianceScale(e){this.uniforms.radianceScale.value=e}get background(){return null!=this.defines.BACKGROUND}set background(e){e!==this.background&&(e?this.defines.BACKGROUND="1":delete this.defines.BACKGROUND,this.needsUpdate=!0)}}const Wn=new e,Vn=new t,jn={ellipsoid:$.WGS84,correctAltitude:!0,photometric:!0,distance:1};class qn extends w{constructor(n,i=Ie.DEFAULT){super(),Ae(this,"transmittanceTexture"),Ae(this,"ellipsoid"),Ae(this,"ellipsoidCenter",new e),Ae(this,"ellipsoidMatrix",new t),Ae(this,"correctAltitude"),Ae(this,"photometric"),Ae(this,"sunDirection"),Ae(this,"distance"),this.atmosphere=i;const{irradianceTexture:r=null,ellipsoid:o,correctAltitude:a,photometric:s,sunDirection:c,distance:u}={...jn,...n};this.transmittanceTexture=r,this.ellipsoid=o,this.correctAltitude=a,this.photometric=s,this.sunDirection=(null==c?void 0:c.clone())??new e,this.distance=u}update(){if(this.position.copy(this.sunDirection).applyMatrix4(this.ellipsoidMatrix).normalize().multiplyScalar(this.distance).add(this.target.position),null==this.transmittanceTexture)return;const e=Vn.copy(this.ellipsoidMatrix).invert(),t=this.target.getWorldPosition(Wn).applyMatrix4(e).sub(this.ellipsoidCenter);Cn(this.transmittanceTexture,t,this.sunDirection,this.color,{ellipsoid:this.ellipsoid,correctAltitude:this.correctAltitude,photometric:this.photometric},this.atmosphere)}}var Yn=Object.defineProperty,Xn=(e,t,n)=>((e,t,n)=>t in e?Yn(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);P.SRC;const Kn={blendFunction:P.NORMAL};class $n extends U{constructor(e){const{blendFunction:t}={...Kn,...e};super("DitheringEffect","#define DITHERING\n\n#include <dithering_pars_fragment>\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  outputColor = vec4(saturate(dithering(inputColor.rgb)), inputColor.a);\n}\n",{blendFunction:t})}}const Zn={thresholdLevel:10,thresholdRange:1};class Jn extends C{constructor(e){const{inputBuffer:t=null,thresholdLevel:n,thresholdRange:i,...r}={...Zn,...e};super({name:"DownsampleThresholdMaterial",fragmentShader:"#include <common>\n\nuniform sampler2D inputBuffer;\n\nuniform float thresholdLevel;\nuniform float thresholdRange;\n\nin vec2 vCenterUv1;\nin vec2 vCenterUv2;\nin vec2 vCenterUv3;\nin vec2 vCenterUv4;\nin vec2 vRowUv1;\nin vec2 vRowUv2;\nin vec2 vRowUv3;\nin vec2 vRowUv4;\nin vec2 vRowUv5;\nin vec2 vRowUv6;\nin vec2 vRowUv7;\nin vec2 vRowUv8;\nin vec2 vRowUv9;\n\nfloat clampToBorder(const vec2 uv) {\n  return float(uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0);\n}\n\n// Reference: https://learnopengl.com/Guest-Articles/2022/Phys.-Based-Bloom\nvoid main() {\n  vec3 color = 0.125 * texture(inputBuffer, vec2(vRowUv5)).rgb;\n  vec4 weight =\n    0.03125 *\n    vec4(\n      clampToBorder(vRowUv1),\n      clampToBorder(vRowUv3),\n      clampToBorder(vRowUv7),\n      clampToBorder(vRowUv9)\n    );\n  color += weight.x * texture(inputBuffer, vec2(vRowUv1)).rgb;\n  color += weight.y * texture(inputBuffer, vec2(vRowUv3)).rgb;\n  color += weight.z * texture(inputBuffer, vec2(vRowUv7)).rgb;\n  color += weight.w * texture(inputBuffer, vec2(vRowUv9)).rgb;\n\n  weight =\n    0.0625 *\n    vec4(\n      clampToBorder(vRowUv2),\n      clampToBorder(vRowUv4),\n      clampToBorder(vRowUv6),\n      clampToBorder(vRowUv8)\n    );\n  color += weight.x * texture(inputBuffer, vec2(vRowUv2)).rgb;\n  color += weight.y * texture(inputBuffer, vec2(vRowUv4)).rgb;\n  color += weight.z * texture(inputBuffer, vec2(vRowUv6)).rgb;\n  color += weight.w * texture(inputBuffer, vec2(vRowUv8)).rgb;\n\n  weight =\n    0.125 *\n    vec4(\n      clampToBorder(vRowUv2),\n      clampToBorder(vRowUv4),\n      clampToBorder(vRowUv6),\n      clampToBorder(vRowUv8)\n    );\n  color += weight.x * texture(inputBuffer, vec2(vCenterUv1)).rgb;\n  color += weight.y * texture(inputBuffer, vec2(vCenterUv2)).rgb;\n  color += weight.z * texture(inputBuffer, vec2(vCenterUv3)).rgb;\n  color += weight.w * texture(inputBuffer, vec2(vCenterUv4)).rgb;\n\n  // WORKAROUND: Avoid screen flashes if the input buffer contains NaN texels.\n  // See: https://github.com/takram-design-engineering/three-geospatial/issues/7\n  if (any(isnan(color))) {\n    gl_FragColor = vec4(vec3(0.0), 1.0);\n    return;\n  }\n\n  float l = luminance(color);\n  float scale = saturate(smoothstep(thresholdLevel, thresholdLevel + thresholdRange, l));\n  gl_FragColor = vec4(color * scale, 1.0);\n}\n",vertexShader:"uniform vec2 texelSize;\n\nout vec2 vCenterUv1;\nout vec2 vCenterUv2;\nout vec2 vCenterUv3;\nout vec2 vCenterUv4;\nout vec2 vRowUv1;\nout vec2 vRowUv2;\nout vec2 vRowUv3;\nout vec2 vRowUv4;\nout vec2 vRowUv5;\nout vec2 vRowUv6;\nout vec2 vRowUv7;\nout vec2 vRowUv8;\nout vec2 vRowUv9;\n\nvoid main() {\n  vec2 uv = position.xy * 0.5 + 0.5;\n  vCenterUv1 = uv + texelSize * vec2(-1.0, 1.0);\n  vCenterUv2 = uv + texelSize * vec2(1.0, 1.0);\n  vCenterUv3 = uv + texelSize * vec2(-1.0, -1.0);\n  vCenterUv4 = uv + texelSize * vec2(1.0, -1.0);\n  vRowUv1 = uv + texelSize * vec2(-2.0, 2.0);\n  vRowUv2 = uv + texelSize * vec2(0.0, 2.0);\n  vRowUv3 = uv + texelSize * vec2(2.0, 2.0);\n  vRowUv4 = uv + texelSize * vec2(-2.0, 0.0);\n  vRowUv5 = uv + texelSize;\n  vRowUv6 = uv + texelSize * vec2(2.0, 0.0);\n  vRowUv7 = uv + texelSize * vec2(-2.0, -2.0);\n  vRowUv8 = uv + texelSize * vec2(0.0, -2.0);\n  vRowUv9 = uv + texelSize * vec2(2.0, -2.0);\n\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",blending:I,toneMapped:!1,depthWrite:!1,depthTest:!1,...r,uniforms:{inputBuffer:new m(t),texelSize:new m(new f),thresholdLevel:new m(n),thresholdRange:new m(i),...r.uniforms}})}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(e){this.uniforms.inputBuffer.value=e}get thresholdLevel(){return this.uniforms.thresholdLevel.value}set thresholdLevel(e){this.uniforms.thresholdLevel.value=e}get thresholdRange(){return this.uniforms.thresholdRange.value}set thresholdRange(e){this.uniforms.thresholdRange.value=e}}const Qn={ghostAmount:.001,haloAmount:.001,chromaticAberration:10};class ei extends C{constructor(e){const{inputBuffer:t=null,ghostAmount:n,haloAmount:i,chromaticAberration:r,...o}={...Qn,...e};super({name:"LensFlareFeaturesMaterial",fragmentShader:"#include <common>\n\n#define SQRT_2 (0.7071067811865476)\n\nuniform sampler2D inputBuffer;\n\nuniform vec2 texelSize;\nuniform float ghostAmount;\nuniform float haloAmount;\nuniform float chromaticAberration;\n\nin vec2 vUv;\nin vec2 vAspectRatio;\n\nvec3 sampleGhost(const vec2 direction, const vec3 color, const float offset) {\n  vec2 suv = clamp(1.0 - vUv + direction * offset, 0.0, 1.0);\n  vec3 result = texture(inputBuffer, suv).rgb * color;\n\n  // Falloff at the perimeter.\n  float d = clamp(length(0.5 - suv) / (0.5 * SQRT_2), 0.0, 1.0);\n  result *= pow(1.0 - d, 3.0);\n  return result;\n}\n\nvec4 sampleGhosts(float amount) {\n  vec3 color = vec3(0.0);\n  vec2 direction = vUv - 0.5;\n  color += sampleGhost(direction, vec3(0.8, 0.8, 1.0), -5.0);\n  color += sampleGhost(direction, vec3(1.0, 0.8, 0.4), -1.5);\n  color += sampleGhost(direction, vec3(0.9, 1.0, 0.8), -0.4);\n  color += sampleGhost(direction, vec3(1.0, 0.8, 0.4), -0.2);\n  color += sampleGhost(direction, vec3(0.9, 0.7, 0.7), -0.1);\n  color += sampleGhost(direction, vec3(0.5, 1.0, 0.4), 0.7);\n  color += sampleGhost(direction, vec3(0.5, 0.5, 0.5), 1.0);\n  color += sampleGhost(direction, vec3(1.0, 1.0, 0.6), 2.5);\n  color += sampleGhost(direction, vec3(0.5, 0.8, 1.0), 10.0);\n  return vec4(color * amount, 1.0);\n}\n\n// Reference: https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html\nfloat cubicRingMask(const float x, const float radius, const float thickness) {\n  float v = min(abs(x - radius) / thickness, 1.0);\n  return 1.0 - v * v * (3.0 - 2.0 * v);\n}\n\nvec3 sampleHalo(const float radius) {\n  vec2 direction = normalize((vUv - 0.5) / vAspectRatio) * vAspectRatio;\n  vec3 offset = vec3(texelSize.x * chromaticAberration) * vec3(-1.0, 0.0, 1.0);\n  vec2 suv = fract(1.0 - vUv + direction * radius);\n  vec3 result = vec3(\n    texture(inputBuffer, suv + direction * offset.r).r,\n    texture(inputBuffer, suv + direction * offset.g).g,\n    texture(inputBuffer, suv + direction * offset.b).b\n  );\n\n  // Falloff at the center and perimeter.\n  vec2 wuv = (vUv - vec2(0.5, 0.0)) / vAspectRatio + vec2(0.5, 0.0);\n  float d = saturate(distance(wuv, vec2(0.5)));\n  result *= cubicRingMask(d, 0.45, 0.25);\n  return result;\n}\n\nvec4 sampleHalos(const float amount) {\n  vec3 color = vec3(0.0);\n  color += sampleHalo(0.3);\n  return vec4(color, 1.0) * amount;\n}\n\nvoid main() {\n  gl_FragColor += sampleGhosts(ghostAmount);\n  gl_FragColor += sampleHalos(haloAmount);\n}\n\n",vertexShader:"uniform vec2 texelSize;\n\nout vec2 vUv;\nout vec2 vAspectRatio;\n\nvoid main() {\n  vUv = position.xy * 0.5 + 0.5;\n  vAspectRatio = vec2(texelSize.x / texelSize.y, 1.0);\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}\n",blending:I,toneMapped:!1,depthWrite:!1,depthTest:!1,uniforms:{inputBuffer:new m(t),texelSize:new m(new f),ghostAmount:new m(n),haloAmount:new m(i),chromaticAberration:new m(r),...o.uniforms}})}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(e){this.uniforms.inputBuffer.value=e}get ghostAmount(){return this.uniforms.ghostAmount.value}set ghostAmount(e){this.uniforms.ghostAmount.value=e}get haloAmount(){return this.uniforms.haloAmount.value}set haloAmount(e){this.uniforms.haloAmount.value=e}get chromaticAberration(){return this.uniforms.chromaticAberration.value}set chromaticAberration(e){this.uniforms.chromaticAberration.value=e}}const ti={blendFunction:P.NORMAL,resolutionScale:.5,width:H.AUTO_SIZE,height:H.AUTO_SIZE,intensity:.005};class ni extends U{constructor(e){const{blendFunction:t,resolutionScale:n,width:i,height:r,resolutionX:o=i,resolutionY:a=r,intensity:s}={...ti,...e};super("LensFlareEffect","uniform sampler2D bloomBuffer;\nuniform sampler2D featuresBuffer;\nuniform float intensity;\n\nvoid mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {\n  vec3 bloom = texture(bloomBuffer, uv).rgb;\n  vec3 features = texture(featuresBuffer, uv).rgb;\n  outputColor = vec4(inputColor.rgb + (bloom + features) * intensity, inputColor.a);\n}\n",{blendFunction:t,attributes:L.CONVOLUTION,uniforms:new Map(Object.entries({bloomBuffer:new m(null),featuresBuffer:new m(null),intensity:new m(1)}))}),Xn(this,"resolution"),Xn(this,"renderTarget1"),Xn(this,"renderTarget2"),Xn(this,"thresholdMaterial"),Xn(this,"thresholdPass"),Xn(this,"blurPass"),Xn(this,"preBlurPass"),Xn(this,"featuresMaterial"),Xn(this,"featuresPass"),Xn(this,"onResolutionChange",(()=>{this.setSize(this.resolution.baseWidth,this.resolution.baseHeight)})),this.renderTarget1=new A(1,1,{depthBuffer:!1,stencilBuffer:!1,type:x}),this.renderTarget1.texture.name="LensFlare.Target1",this.renderTarget2=new A(1,1,{depthBuffer:!1,stencilBuffer:!1,type:x}),this.renderTarget2.texture.name="LensFlare.Target2",this.thresholdMaterial=new Jn,this.thresholdPass=new G(this.thresholdMaterial),this.blurPass=new F,this.blurPass.levels=8,this.preBlurPass=new z({kernelSize:B.SMALL}),this.featuresMaterial=new ei,this.featuresPass=new G(this.featuresMaterial),this.uniforms.get("bloomBuffer").value=this.blurPass.texture,this.uniforms.get("featuresBuffer").value=this.renderTarget1.texture,this.resolution=new H(this,o,a,n),this.resolution.addEventListener("change",this.onResolutionChange),this.intensity=s}initialize(e,t,n){this.thresholdPass.initialize(e,t,n),this.blurPass.initialize(e,t,n),this.preBlurPass.initialize(e,t,n),this.featuresPass.initialize(e,t,n)}update(e,t,n){this.thresholdPass.render(e,t,this.renderTarget1),this.blurPass.render(e,this.renderTarget1,null),this.preBlurPass.render(e,this.renderTarget1,this.renderTarget2),this.featuresPass.render(e,this.renderTarget2,this.renderTarget1)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t);const{width:i,height:r}=n;this.renderTarget1.setSize(i,r),this.renderTarget2.setSize(i,r),this.thresholdMaterial.setSize(i,r),this.blurPass.setSize(i,r),this.preBlurPass.setSize(i,r),this.featuresMaterial.setSize(i,r)}get intensity(){return this.uniforms.get("intensity").value}set intensity(e){this.uniforms.get("intensity").value=e}get thresholdLevel(){return this.thresholdMaterial.thresholdLevel}set thresholdLevel(e){this.thresholdMaterial.thresholdLevel=e}get thresholdRange(){return this.thresholdMaterial.thresholdRange}set thresholdRange(e){this.thresholdMaterial.thresholdRange=e}}P.SRC;const ii=new ee,ri=new e,oi=new e,ai=new e,si=new e;class ci{set neesUpdate(e){!0===e&&(this.cacheKey=Math.random().toString())}constructor(n){this.ssp=n,this.cacheKey="",this.date=new Date,this.longitude=120,this.latitude=30,this.altitude=20,this.distance=300,this.target=new e,this.groundAlbedo=6710886,this.castShadow=!0,this.atmosphereProps={rotationMatrix:new t,sunDirection:new e,moonDirection:new e,ellipsoidCenter:new e,ellipsoidMatrix:new t},this.starsPoints=null,this._started=!1,this.update=()=>{const{date:t,longitude:n,latitude:i,altitude:r,distance:o,target:a,groundAlbedo:s,castShadow:c,skyMaterial:u,skyLight:l,sunLight:d,aerialPerspectiveEffect:h,starsPoints:m}=this,{rotationMatrix:f,sunDirection:v,moonDirection:p,ellipsoidCenter:_,ellipsoidMatrix:g}=this.atmosphereProps,{ssp:{viewport:{renderer:T}}}=this;mn(t,f),function(t,n=new e){return fn(ot.Sun,hn(t),n)}(t,v).applyMatrix4(f),function(t,n=new e){return fn(ot.Moon,hn(t),n)}(t,p).applyMatrix4(f),ii.set(fe(n),fe(i),r),ii.toECEF(ri),_.copy(ri).multiplyScalar(-1),$.WGS84.getEastNorthUpVectors(ri,oi,ai,si),g.makeBasis(ai,si,oi).invert(),u.groundAlbedo.set(s),u.sunDirection.copy(v),u.moonDirection.copy(p),u.ellipsoidCenter.copy(_),u.ellipsoidMatrix.copy(g),l.sunDirection.copy(v),l.ellipsoidCenter.copy(_),l.ellipsoidMatrix.copy(g),l.position.copy(a),d.castShadow=c,d.distance=o,d.shadow.camera.top=o,d.shadow.camera.bottom=-o,d.shadow.camera.left=-o,d.shadow.camera.right=o,d.shadow.camera.far=2*o,d.sunDirection.copy(v),d.ellipsoidCenter.copy(_),d.ellipsoidMatrix.copy(g),d.target.position.copy(a),h.sunDirection.copy(v),h.moonDirection.copy(p),h.ellipsoidCenter.copy(_),h.ellipsoidMatrix.copy(g),m&&(m.setRotationFromMatrix(f),m.material.sunDirection.copy(v),m.material.ellipsoidCenter.copy(_),m.material.ellipsoidMatrix.copy(g));const R=this.getCacheKey();R!==this.cacheKey&&(this.cacheKey=R,c&&(d.shadow.needsUpdate=!0,d.shadow.camera.updateProjectionMatrix()),this.cubeCamera.update(T,this.skyMesh)),l.update(),d.update()};const{viewport:{renderer:i}}=n;this.date.setHours(10,0,0,0),this.texturesLoader=new Mn,this.texturesLoader.useHalfFloat=null==i.getContext().getExtension("OES_texture_float_linear"),this.arrayBufferLoader=new oe,this.skyMaterial=new Fn,this.skyMesh=new M(new N(2,2),this.skyMaterial),this.skyMesh.frustumCulled=!1,this.skyMesh.renderOrder=100,this.skyLight=new Hn,this.sunLight=new qn,this.sunLight.shadow.autoUpdate=!1,this.sunLight.shadow.bias=-5e-4,this.sunLight.shadow.normalBias=.5,this.sunLight.shadow.camera.near=.01,this.sunLight.shadow.mapSize.width=i.capabilities.maxTextureSize,this.sunLight.shadow.mapSize.height=i.capabilities.maxTextureSize,this.aerialPerspectiveEffect=new Fe,this.aerialPerspective={effect:this.aerialPerspectiveEffect,enabled:!1},this.lensFlareEffect=new ni,this.lensFlare={effect:this.lensFlareEffect,enabled:!1},this.ditheringEffect=new $n,this.dithering={effect:this.ditheringEffect,enabled:!1},this.cubeRenderTarget=new D(512,{type:x}),this.cubeCamera=new O(.1,1e3,this.cubeRenderTarget)}getCacheKey(){const{date:e,longitude:t,latitude:n,altitude:i,distance:r,target:o,groundAlbedo:a,castShadow:s}=this;return`${e.getFullYear()}-${e.getMonth()}-${e.getDate()}-${e.getHours()}-${e.getMinutes()}-${t}-${n}-${i}-${r}-${o.x}-${o.y}-${o.z}-${a}-${s}`}start(e){if(this._started)return;this._started=!0;const{scene:t,camera:n,effectManager:i,signals:r}=this.ssp.viewport;(async()=>{const n=await this.texturesLoader.loadAsync(e);if(!this._started)return;Object.assign(this.skyMaterial,n),this.skyMaterial.useHalfFloat=this.texturesLoader.useHalfFloat,this.sunLight.transmittanceTexture=n.transmittanceTexture,this.skyLight.irradianceTexture=n.irradianceTexture,Object.assign(this.aerialPerspectiveEffect,n),this.aerialPerspectiveEffect.useHalfFloat=this.texturesLoader.useHalfFloat,this.neesUpdate=!0,this.ssp.render();const i=await this.arrayBufferLoader.loadAsync(`${e}/stars.bin`);if(!this._started)return;const r=new b(new zn(i),new kn({pointSize:3,depthTest:!0,depthWrite:!1}));Object.assign(r.material,n),r.material.useHalfFloat=this.texturesLoader.useHalfFloat,r.frustumCulled=!1,r.renderOrder=101,this.starsPoints=r,t.add(r),this.ssp.render()})(),t.add(this.skyMesh),t.add(this.skyLight),t.add(this.sunLight),t.add(this.sunLight.target),this.aerialPerspective.enabled=!0,this.aerialPerspectiveEffect.mainCamera=n,this.lensFlare.enabled=!0,this.dithering.enabled=!0;const o=i.effectsMap.get("smaaEffect");o&&(o.enabled=!1),this.ssp.setToneMapping({type:"AGX",exposure:10}),t.environment=this.cubeRenderTarget.texture,i.effectsMap.set("aerialPerspectiveEffect",this.aerialPerspective),i.effectsMap.set("lensFlareEffect",this.lensFlare),i.effectsMap.set("ditheringEffect",this.dithering),i.effectsNeedsUpdate=!0,r.beforeRender.add(this.update)}stop(){if(!this._started)return;this._started=!1;const{scene:e,effectManager:t,signals:n}=this.ssp.viewport;this.starsPoints&&e.remove(this.starsPoints),e.remove(this.skyMesh),e.remove(this.skyLight),e.remove(this.sunLight),e.remove(this.sunLight.target),this.aerialPerspective.enabled=!1,this.lensFlare.enabled=!1,this.dithering.enabled=!1;const i=t.effectsMap.get("smaaEffect");i&&(i.enabled=!0),this.ssp.setToneMapping({type:"ACESFilmic",exposure:.8}),this.ssp.setEnvironment(),t.effectsMap.delete("aerialPerspectiveEffect"),t.effectsMap.delete("lensFlareEffect"),t.effectsMap.delete("ditheringEffect"),t.effectsNeedsUpdate=!0,n.beforeRender.remove(this.update),this.ssp.render()}dispose(){var e,t;this.stop(),this.skyMesh.geometry.dispose(),this.skyMesh.material.dispose(),this.skyLight.dispose(),this.sunLight.dispose(),null===(e=this.starsPoints)||void 0===e||e.geometry.dispose(),null===(t=this.starsPoints)||void 0===t||t.material.dispose()}}export{ci as default};
